<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Michele - Motion Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #ffffff;
            overflow: hidden;
        }
        
        /* Header Navigation */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: #ffffff;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
        }
        
        .logo {
            font-size: 20px;
            font-weight: 700;
            color: #FF6700;
            margin-right: 40px;
            display: flex;
            align-items: center;
        }
        
        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #FF6700, #FF8C42);
            border-radius: 6px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 900;
            font-size: 18px;
        }
        
        .tabs {
            display: flex;
            gap: 8px;
            flex: 1;
        }
        
        .tab {
            padding: 8px 20px;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            height: 60px;
            display: flex;
            align-items: center;
        }
        
        .tab:hover {
            color: #333;
            background: #f8f8f8;
        }
        
        .tab.active {
            color: #FF6700;
            border-bottom-color: #FF6700;
            background: #fff8f3;
        }
        
        /* Canvas Container */
        #canvas-container {
            width: 100vw;
            height: calc(100vh - 60px);
            margin-top: 60px;
            position: relative;
        }
        
        /* Tab Content */
        .tab-content {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .tab-content.active {
            display: block;
        }
        
        #artifacts-tab {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
            z-index: 100;
        }
        
        h1 {
            font-size: 24px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }
        
        .info-item {
            font-size: 14px;
            color: #666;
            margin: 4px 0;
        }
        
        .status {
            display: inline-block;
            padding: 4px 12px;
            background: #4CAF50;
            color: white;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            margin-top: 8px;
        }
        
        .loading {
            background: #FF9800;
        }
        
        .error {
            background: #f44336;
        }
        
        /* Animations Tab Styles */
        #animations-sidebar {
            position: absolute;
            left: 0;
            top: 0;
            width: 280px;
            height: 100%;
            background: #f8f8f8;
            border-right: 1px solid #e0e0e0;
            overflow-y: auto;
            z-index: 10;
        }
        
        .search-bar {
            padding: 16px;
            background: white;
            border-bottom: 1px solid #e0e0e0;
            position: sticky;
            top: 0;
            z-index: 11;
        }
        
        .search-bar input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
        }
        
        .search-bar input:focus {
            outline: none;
            border-color: #FF6700;
        }
        
        .motion-grid {
            padding: 16px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        .motion-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .motion-card:hover {
            border-color: #FF6700;
            box-shadow: 0 2px 8px rgba(255, 103, 0, 0.1);
        }
        
        .motion-card.active {
            border-color: #FF6700;
            background: #fff8f3;
        }
        
        .motion-thumbnail {
            width: 100%;
            aspect-ratio: 16/9;
            background: linear-gradient(135deg, #f0f0f0, #e0e0e0);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            color: #999;
            position: relative;
            overflow: hidden;
        }
        
        .motion-thumbnail canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .motion-thumbnail .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #999;
            font-size: 14px;
        }
        
        .motion-info {
            padding: 12px;
        }
        
        .motion-name {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }
        
        .motion-details {
            font-size: 12px;
            color: #666;
        }
        
        .trimming-controls {
            margin-top: 8px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }
        
        .trim-range-container {
            margin-bottom: 8px;
        }
        
        .trim-range-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            color: #555;
            margin-bottom: 6px;
            font-weight: 500;
        }
        
        .trim-frame-count {
            color: #777;
            font-size: 10px;
        }
        
        .trim-range-slider {
            position: relative;
            height: 20px;
        }
        
        .trim-range-input {
            position: absolute;
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: transparent;
            outline: none;
            -webkit-appearance: none;
            pointer-events: none;
        }
        
        .trim-range-input.trim-start {
            z-index: 3;
        }
        
        .trim-range-input.trim-end {
            z-index: 4;
        }
        
        .trim-range-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #FF6700;
            cursor: grab;
            pointer-events: auto;
            border: 3px solid #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
            transition: all 0.15s ease;
        }
        
        .trim-range-input::-webkit-slider-thumb:hover {
            background: #FF8C42;
            transform: scale(1.15);
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        
        .trim-range-input::-webkit-slider-thumb:active {
            cursor: grabbing;
            transform: scale(1.05);
        }
        
        .trim-range-input::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #FF6700;
            cursor: grab;
            pointer-events: auto;
            border: 3px solid #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
            transition: all 0.15s ease;
        }
        
        .trim-range-input::-moz-range-thumb:hover {
            background: #FF8C42;
            transform: scale(1.15);
        }
        
        .trim-range-input::-moz-range-thumb:active {
            cursor: grabbing;
            transform: scale(1.05);
        }
        
        .trim-range-track {
            position: absolute;
            top: 50%;
            left: 8px;
            right: 8px;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            transform: translateY(-50%);
            z-index: 1;
        }
        
        .trim-range-track::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #FF6700;
            border-radius: 2px;
            z-index: 2;
        }
        
        .trim-info {
            text-align: center;
            margin-top: 6px;
        }
        
        .trim-info small {
            color: #777;
            font-size: 10px;
        }
        
        .blend-flags {
            display: flex;
            gap: 6px;
            padding: 8px;
            border-top: 1px solid #e0e0e0;
            background: #f8f8f8;
        }
        
        .flag-btn {
            flex: 1;
            padding: 6px;
            border: 2px solid transparent;
            background: white;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .flag-btn:hover {
            transform: scale(1.1);
            border-color: currentColor;
        }
        
        .flag-btn.green {
            color: #4CAF50;
        }
        
        .flag-btn.blue {
            color: #2196F3;
        }
        
        .flag-btn.orange {
            color: #FF9800;
        }
        
        .flag-btn.active {
            border-color: currentColor;
            box-shadow: 0 0 8px currentColor;
            background: rgba(255, 255, 255, 0.95);
            font-weight: 700;
        }
        
        .animation-viewer {
            margin-left: 280px;
            width: calc(100% - 280px);
            height: 100%;
            position: relative;
            background: #fafafa; /* Light background to verify div is visible */
        }
        
        .animation-viewer canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .playback-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 16px;
            z-index: 100;
        }
        
        .play-button {
            width: 40px;
            height: 40px;
            border: none;
            background: #FF6700;
            color: white;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
        }
        
        .play-button:hover {
            background: #FF8C42;
            transform: scale(1.05);
        }
        
        .ai-gen-btn {
            width: 32px;
            height: 32px;
            border: 2px solid #e0e0e0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            margin-left: 8px;
            position: relative;
        }
        
        .ai-gen-btn:hover {
            transform: scale(1.1) rotate(15deg);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            border-color: #667eea;
        }
        
        .ai-gen-btn:active {
            transform: scale(0.95) rotate(-15deg);
        }
        
        .ai-gen-btn:disabled {
            background: #e0e0e0;
            cursor: not-allowed;
            border-color: #d0d0d0;
            color: #999;
        }
        
        .ai-gen-btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }
        
        .ai-gen-btn.loading {
            animation: sparkle 1.5s infinite;
        }
        
        @keyframes sparkle {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.1) rotate(15deg); }
            50% { transform: scale(1) rotate(0deg); }
            75% { transform: scale(1.1) rotate(-15deg); }
        }
        
        /* Floating Popups */
        .artifacts-success-popup,
        .artifacts-error-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20000;
            animation: popupSlideIn 0.3s ease-out;
        }
        
        .artifacts-success-popup .popup-content {
            background: white;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            min-width: 400px;
        }
        
        .artifacts-error-popup .popup-content {
            background: white;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            min-width: 400px;
        }
        
        .popup-icon {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
            font-size: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 24px;
            box-shadow: 0 8px 20px rgba(76, 175, 80, 0.4);
        }
        
        .popup-icon.error {
            background: linear-gradient(135deg, #f44336, #e57373);
            box-shadow: 0 8px 20px rgba(244, 67, 54, 0.4);
        }
        
        .popup-title {
            font-size: 24px;
            font-weight: 700;
            color: #333;
            margin-bottom: 8px;
        }
        
        .popup-subtitle {
            font-size: 14px;
            color: #666;
            margin-bottom: 24px;
        }
        
        .popup-metrics {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-bottom: 32px;
        }
        
        .metric {
            padding: 16px 24px;
            background: #f8f9fa;
            border-radius: 12px;
            min-width: 120px;
        }
        
        .metric-label {
            display: block;
            font-size: 11px;
            color: #999;
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .metric-value {
            display: block;
            font-size: 20px;
            color: #333;
            font-weight: 700;
            text-transform: capitalize;
        }
        
        .popup-action-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 32px;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }
        
        .popup-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }
        
        .popup-action-btn.retry {
            background: linear-gradient(135deg, #f44336, #e57373);
        }
        
        .popup-action-btn.retry:hover {
            box-shadow: 0 8px 20px rgba(244, 67, 54, 0.4);
        }
        
        .artifacts-success-popup.fade-out,
        .artifacts-error-popup.fade-out {
            animation: popupSlideOut 0.3s ease-in forwards;
        }
        
        @keyframes popupSlideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        @keyframes popupSlideOut {
            from {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
            to {
                opacity: 0;
                transform: translate(-50%, -40%);
            }
        }
        
        /* Artifacts Tab New Layout */
        #artifacts-animation-card {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            z-index: 200;
        }
        
        .artifacts-card-header {
            padding: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .artifacts-card-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
        }
        
        .artifacts-card-thumbnail {
            width: 100%;
            height: 200px;
            background: #f5f5f5;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;  /* Clickable to play */
            transition: transform 0.2s;
        }
        
        .artifacts-card-thumbnail:hover {
            transform: scale(1.02);
        }
        
        .thumbnail-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .artifacts-card-info {
            padding: 16px;
            background: white;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .info-row:last-child {
            border-bottom: none;
        }
        
        .info-row .label {
            font-size: 13px;
            color: #666;
            font-weight: 500;
        }
        
        .info-row .value {
            font-size: 13px;
            color: #333;
            font-weight: 600;
        }
        
        .info-row .value.quality-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            text-transform: capitalize;
        }
        
        .artifacts-viewport {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            bottom: 140px;
            background: #fafafa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            z-index: 1;
        }
        
        .artifacts-viewport canvas {
            width: 100%;
            height: 100%;
        }
        
        .artifacts-blend-output {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            width: 100%;
            background: #FAFAFA;
            padding: 12px;
            box-sizing: border-box;
            border: 2px dotted #CCCCCC;
            border-radius: 8px;
            z-index: 100;
        }
        
        .blend-output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .blend-output-header .strip-label {
            font-size: 11px;
            color: #666;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .blend-output-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .blend-output-actions .gemini-option {
            font-size: 11px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .blend-output-actions .ai-gen-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            font-size: 12px;
        }
        
        .artifacts-status {
            margin-bottom: 8px;
        }
        
        .artifacts-blend-output .strip-timeline {
            position: relative;
            height: 80px;
        }
        
        .artifacts-blend-output .frame-previews {
            display: flex;
            gap: 0;
            overflow-x: auto;
            height: 80px;
            padding: 4px;
        }
        
        .artifacts-blend-output .frame-previews canvas {
            flex-shrink: 0;
            margin-left: -15px;
        }
        
        .artifacts-blend-output .frame-previews canvas:first-child {
            margin-left: 0;
        }
        
        .artifacts-blend-output .frame-previews::-webkit-scrollbar {
            height: 4px;
        }
        
        .artifacts-blend-output .frame-previews::-webkit-scrollbar-thumb {
            background: rgba(255, 103, 0, 0.5);
            border-radius: 2px;
        }
        
        .artifacts-blend-output .blend-overlap-viz {
            position: absolute;
            bottom: 0;
            left: 4px;
            right: 4px;
            height: 20px;
            pointer-events: auto;
        }
        
        .artifacts-blend-shadow {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20px;
            opacity: 0.3;
            background: linear-gradient(to right, #4CAF50, #2196F3, #FF6700);
        }
        
        /* Circular spinner around AI gen button */
        .ai-gen-btn.generating::after {
            content: '';
            position: absolute;
            top: -6px;
            left: -6px;
            right: -6px;
            bottom: -6px;
            border: 3px solid transparent;
            border-top-color: #667eea;
            border-right-color: #667eea;
            border-radius: 50%;
            animation: spinner 1s linear infinite;
        }
        
        @keyframes spinner {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .timeline {
            flex: 1;
            min-width: 200px;
        }
        
        .timeline input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }
        
        .timeline input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #FF6700;
            cursor: pointer;
        }
        
        .frame-display {
            font-size: 12px;
            color: #666;
            font-family: 'Courier New', monospace;
            min-width: 120px;
            text-align: center;
        }
        
        /* Blend Tab Styles */
        #blend-control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }
        
        #blend-control-panel h2 {
            margin: 0 0 12px 0;
            font-size: 18px;
            color: #333;
        }
        
        .blend-info {
            margin-bottom: 16px;
        }
        
        .blend-info p {
            margin: 0 0 12px 0;
            font-size: 13px;
            color: #666;
        }
        
        #selected-motions-display {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .selected-motion-slot {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #f8f8f8;
            border-radius: 6px;
            border: 2px solid #e0e0e0;
            cursor: grab;
            transition: all 0.2s;
        }
        
        .selected-motion-slot:active {
            cursor: grabbing;
        }
        
        .selected-motion-slot.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }
        
        .selected-motion-slot.drag-over {
            border-color: #FF6700;
            background: #fff3e0;
        }
        
        .slot-number {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #666;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
        }
        
        .slot-name {
            flex: 1;
            font-size: 13px;
            color: #666;
        }
        
        .slot-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }
        
        .slot-color.green {
            background: #4CAF50;
        }
        
        .slot-color.blue {
            background: #2196F3;
        }
        
        .slot-color.orange {
            background: #FF9800;
        }
        
        .blend-weights-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 2px solid #e0e0e0;
        }
        
        /* Blend Metrics Card */
        #blend-metrics-card {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 320px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
            display: none;
        }
        
        #blend-metrics-card.visible {
            display: block;
        }
        
        #blend-metrics-card h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #blend-metrics-card h3::before {
            content: 'ðŸ“Š';
            font-size: 18px;
        }
        
        .metrics-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .metrics-row:last-child {
            border-bottom: none;
        }
        
        .metric-label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }
        
        .metric-value {
            font-size: 13px;
            color: #333;
            font-weight: 600;
        }
        
        .metric-value.highlight {
            color: #FF6700;
        }
        
        .metric-value.good {
            color: #4CAF50;
        }
        
        .metric-value.warning {
            color: #FF9800;
        }
        
        .compatibility-bar {
            width: 100%;
            height: 6px;
            background: #f0f0f0;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 4px;
        }
        
        .compatibility-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF6700, #FF8C42);
            transition: width 0.3s ease;
        }
        
        .blend-weights-section h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #333;
        }
        
        .weight-slider-container {
            margin-bottom: 12px;
        }
        
        .weight-slider-container label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 12px;
        }
        
        .weight-label {
            color: #666;
            font-weight: 600;
        }
        
        .weight-value {
            color: #FF6700;
            font-weight: 700;
        }
        
        .weight-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .weight-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .green-slider {
            background: #C8E6C9;
        }
        
        .green-slider::-webkit-slider-thumb {
            background: #4CAF50;
        }
        
        .blue-slider {
            background: #BBDEFB;
        }
        
        .blue-slider::-webkit-slider-thumb {
            background: #2196F3;
        }
        
        .orange-slider {
            background: #FFE0B2;
        }
        
        .orange-slider::-webkit-slider-thumb {
            background: #FF9800;
        }
        
        .weight-normalize-info {
            margin-top: 8px;
            text-align: center;
            color: #999;
            font-size: 11px;
        }
        
        .blend-action-btn {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 8px;
        }
        
        .blend-action-btn.primary {
            background: #FF6700;
            color: white;
            border-color: #FF6700;
        }
        
        .blend-action-btn.primary:hover:not(:disabled) {
            background: #FF8C42;
        }
        
        .blend-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .blend-status-indicator {
            padding: 8px;
            background: #f0f0f0;
            border-radius: 4px;
            font-size: 12px;
            color: #666;
            text-align: center;
        }
        
        #animation-strips-container {
            position: absolute;
            top: 20px;
            left: 320px;
            right: 20px;
            bottom: 20px;
            background: white;
            border: none;
            border-radius: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 0;
            overflow: hidden;
        }
        
        .animation-strip {
            flex: 1;
            background: white;
            border: none;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        
        .strip-header {
            padding: 8px 12px;
            background: white;
            border-bottom: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .strip-title {
            font-size: 13px;
            font-weight: 600;
            color: #333;
        }
        
        .strip-badge {
            font-size: 20px;
        }
        
        .strip-badge.green {
            color: #4CAF50;
        }
        
        .strip-badge.blue {
            color: #2196F3;
        }
        
        .strip-badge.orange {
            color: #FF9800;
        }
        
        .strip-timeline {
            height: calc(100% - 36px);
            position: relative;
            overflow: hidden;
            background: white;
        }
        
        .frame-previews {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            min-height: 120px;
            display: flex;
            align-items: center;
            gap: -15px;
            padding: 0;
            overflow-x: auto;
            background: white;
            z-index: 1;
        }
        
        .frame-preview {
            flex-shrink: 0;
            width: 80px;
            height: 80px;
            background: white;
            border: none;
            border-radius: 0;
            overflow: hidden;
        }
        
        .frame-preview canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .frame-thumb {
            flex-shrink: 0;
            width: 80px;
            height: 80px;
            background: white;
            border: none;
            border-radius: 0;
            object-fit: cover;
            cursor: grab;
            transition: transform 0.2s;
        }
        
        .frame-thumb:active {
            cursor: grabbing;
        }
        
        .frame-thumb.dragging {
            opacity: 0.5;
        }
        
        .color-shadow {
            position: absolute;
            bottom: 25px;
            left: 0;
            height: 35px;
            opacity: 0.85;
            border: 2px solid;
            border-radius: 8px;
            box-sizing: border-box;
            z-index: 10;
            pointer-events: auto;
            cursor: grab;
            transition: opacity 0.2s;
        }
        
        .color-shadow:hover {
            opacity: 1;
        }
        
        .color-shadow.dragging {
            cursor: grabbing;
            opacity: 1;
        }
        
        .crosshatch-frame-label {
            position: absolute;
            top: -20px;
            font-size: 10px;
            font-weight: 600;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 4px;
            border-radius: 3px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 11;
        }
        
        .crosshatch-frame-label.start {
            left: 0;
        }
        
        .crosshatch-frame-label.end {
            right: 0;
        }
        
        .green-shadow {
            background: 
                repeating-linear-gradient(
                    45deg,
                    #4CAF50,
                    #4CAF50 0.5px,
                    transparent 0.5px,
                    transparent 6px
                ),
                repeating-linear-gradient(
                    -45deg,
                    #4CAF50,
                    #4CAF50 0.5px,
                    transparent 0.5px,
                    transparent 6px
                ),
                #E8F5E9;
            border-color: #4CAF50;
        }
        
        .blue-shadow {
            background: 
                repeating-linear-gradient(
                    45deg,
                    #2196F3,
                    #2196F3 0.5px,
                    transparent 0.5px,
                    transparent 6px
                ),
                repeating-linear-gradient(
                    -45deg,
                    #2196F3,
                    #2196F3 0.5px,
                    transparent 0.5px,
                    transparent 6px
                ),
                #E3F2FD;
            border-color: #2196F3;
        }
        
        .orange-shadow {
            background: 
                repeating-linear-gradient(
                    45deg,
                    #FF9800,
                    #FF9800 0.5px,
                    transparent 0.5px,
                    transparent 6px
                ),
                repeating-linear-gradient(
                    -45deg,
                    #FF9800,
                    #FF9800 0.5px,
                    transparent 0.5px,
                    transparent 6px
                ),
                #FFF3E0;
            border-color: #FF9800;
        }
        
        .blend-output-strip {
            border: 2px dotted #CCCCCC !important;
            background: #FAFAFA !important;
            padding: 5px !important;
        }
        
        .strip-badge.blend {
            color: #FF6700;
        }
        
        .blend-output-shadow {
            background: 
                repeating-linear-gradient(
                    45deg,
                    rgba(76, 175, 80, 0.4),
                    rgba(76, 175, 80, 0.4) 0.5px,
                    transparent 0.5px,
                    transparent 6px
                ),
                repeating-linear-gradient(
                    -45deg,
                    rgba(33, 150, 243, 0.4),
                    rgba(33, 150, 243, 0.4) 0.5px,
                    transparent 0.5px,
                    transparent 6px
                ),
                repeating-linear-gradient(
                    135deg,
                    rgba(255, 152, 0, 0.4),
                    rgba(255, 152, 0, 0.4) 0.5px,
                    transparent 0.5px,
                    transparent 6px
                ),
                linear-gradient(to top, #FFF8F0, rgba(255, 248, 240, 0.5));
            height: 40px;
            border: 2px solid #FF6700;
            box-sizing: border-box;
        }
        
        .blend-overlap-viz {
            position: absolute;
            bottom: 40px;
            left: 0;
            right: 0;
            height: 20px;
            display: flex;
            align-items: center;
            pointer-events: none;
        }
        
        .overlap-segment {
            height: 100%;
            position: absolute;
            opacity: 0.7;
            cursor: grab;
            pointer-events: auto;
        }
        
        .overlap-segment:hover {
            opacity: 1;
        }
        
        .overlap-segment.dragging {
            cursor: grabbing;
            opacity: 1;
        }
        
        .overlap-segment.green {
            background: repeating-linear-gradient(
                45deg,
                #4CAF50,
                #4CAF50 4px,
                transparent 4px,
                transparent 8px
            );
        }
        
        .overlap-segment.blue {
            background: repeating-linear-gradient(
                -45deg,
                #2196F3,
                #2196F3 4px,
                transparent 4px,
                transparent 8px
            );
        }
        
        .overlap-segment.orange {
            background: repeating-linear-gradient(
                90deg,
                #FF9800,
                #FF9800 4px,
                transparent 4px,
                transparent 8px
            );
        }
        
        #blend-zones-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 5;
        }
        
        .blend-zone {
            position: absolute;
            top: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.4),
                rgba(255, 255, 255, 0.4) 8px,
                transparent 8px,
                transparent 16px
            ),
            repeating-linear-gradient(
                -45deg,
                rgba(0, 0, 0, 0.2),
                rgba(0, 0, 0, 0.2) 8px,
                transparent 8px,
                transparent 16px
            );
        }
        
        #blend-output-section {
            position: absolute;
            top: 590px;
            left: 320px;
            right: 20px;
            bottom: 20px;
            background: white;
            border: 2px solid #FF6700;
            border-radius: 8px;
            padding: 16px;
        }
        
        .output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .output-header h3 {
            margin: 0;
            font-size: 16px;
            color: #FF6700;
        }
        
        .output-metrics {
            display: flex;
            gap: 20px;
            font-size: 12px;
        }
        
        .output-metrics .metric {
            color: #666;
        }
        
        .output-metrics .metric strong {
            margin-right: 4px;
        }
        
        .output-metrics .metric span {
            color: #FF6700;
            font-weight: 700;
        }
        
        .output-viewer-container {
            height: calc(100% - 50px);
            position: relative;
            background: #fafafa;
            border-radius: 6px;
            overflow: hidden;
        }
        
        #blend-output-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .output-color-shadow {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            opacity: 0.6;
        }
        
        .blended-shadow {
            background: linear-gradient(
                to top,
                rgba(255, 103, 0, 0.6),
                rgba(33, 150, 243, 0.4),
                transparent
            );
        }
        
        /* Artifacts Tab Styles */
        #artifacts-sidebar {
            position: absolute;
            top: 0;
            left: 0;
            width: 260px;
            height: 100%;
            background: white;
            border-right: 2px solid #e0e0e0;
            overflow-y: auto;
        }
        
        .sidebar-header {
            padding: 20px;
            border-bottom: 2px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .sidebar-header h2 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }
        
        .refresh-btn {
            width: 32px;
            height: 32px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 50%;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .refresh-btn:hover {
            border-color: #FF6700;
            color: #FF6700;
            transform: rotate(180deg);
        }
        
        .artifacts-grid {
            padding: 12px;
        }
        
        .empty-state {
            padding: 40px 20px;
            text-align: center;
            color: #999;
        }
        
        .empty-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }
        
        .empty-state p {
            margin: 8px 0;
            font-size: 14px;
            font-weight: 600;
            color: #666;
        }
        
        .empty-state small {
            font-size: 12px;
        }
        
        .artifact-viewer {
            position: absolute;
            top: 0;
            left: 280px;
            right: 0;
            height: 100%;
            background: #f5f5f5;
        }
        
        #artifacts-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .metrics-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .panel-header h3 {
            margin: 0;
            font-size: 16px;
            color: #333;
        }
        
        .quality-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
        }
        
        .quality-badge.ultra {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #333;
        }
        
        .quality-badge.high {
            background: linear-gradient(135deg, #C0C0C0, #A8A8A8);
            color: #333;
        }
        
        .quality-badge.medium {
            background: linear-gradient(135deg, #CD7F32, #B8860B);
            color: white;
        }
        
        .quality-badge.low {
            background: #999;
            color: white;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .metric-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .metric-label {
            font-size: 11px;
            color: #666;
            font-weight: 600;
        }
        
        .metric-value {
            font-size: 16px;
            color: #FF6700;
            font-weight: 700;
        }
        
        .metric-value.cost {
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <!-- Header with Tabs -->
    <div id="header">
        <div class="logo">
            <div class="logo-icon">R</div>
            <span>Rydlr Motion Studio</span>
        </div>
        <div class="tabs">
            <button class="tab active" data-tab="characters">Characters</button>
            <button class="tab" data-tab="animations">Animations</button>
            <button class="tab" data-tab="blend">Blend</button>
            <button class="tab" data-tab="artifacts">Artifacts</button>
        </div>
    </div>
    
    <!-- Canvas Container -->
    <div id="canvas-container">
        <!-- Characters Tab Content -->
        <div id="characters-tab" class="tab-content active">
            <canvas id="webgl-canvas"></canvas>
            <div id="info-panel">
                <h1>Michele</h1>
                <div class="info-item" id="model-name">Model: Ch03_nonPBR.fbx</div>
                <div class="info-item" id="pose-name">Pose: T-Pose</div>
                <div class="info-item" id="frame-number">Frame: 0</div>
                <div class="status" id="status">Loading...</div>
            </div>
        </div>
        
        <!-- Animations Tab Content -->
        <div id="animations-tab" class="tab-content">
            <!-- Sidebar with motion selector -->
            <div id="animations-sidebar">
                <div class="search-bar">
                    <input type="text" id="motion-search" placeholder="Search animations..." />
                </div>
                <div class="motion-grid" id="motion-grid">
                    <!-- Motion cards will be populated here -->
                </div>
            </div>
            
            <!-- Animation viewer -->
            <div class="animation-viewer">
                <canvas id="animations-canvas"></canvas>
                
                <!-- Playback controls -->
                <div class="playback-controls" id="playback-controls" style="display: none;">
                    <button class="play-button" id="play-pause-btn">â–¶</button>
                    <div class="timeline">
                        <input type="range" id="timeline-slider" min="0" max="100" value="0" />
                    </div>
                    <div class="frame-display" id="frame-display">Frame 0/0</div>
                </div>
            </div>
        </div>
        
        <!-- Blend Tab Content -->
        <div id="blend-tab" class="tab-content">
            <!-- Blend Controls Panel (Left Side) -->
            <div id="blend-control-panel">
                <h2>Motion Blending</h2>
                <div class="blend-info">
                    <p>Select 2-3 motions from the Animations tab to blend</p>
                    <div id="selected-motions-display">
                        <div class="selected-motion-slot" data-slot="1">
                            <span class="slot-number">1</span>
                            <span class="slot-name">Empty</span>
                            <div class="slot-color green"></div>
                        </div>
                        <div class="selected-motion-slot" data-slot="2">
                            <span class="slot-number">2</span>
                            <span class="slot-name">Empty</span>
                            <div class="slot-color blue"></div>
                        </div>
                        <div class="selected-motion-slot" data-slot="3">
                            <span class="slot-number">3</span>
                            <span class="slot-name">Empty</span>
                            <div class="slot-color orange"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Proceed to Blend Button (shown when motions are trimmed and selected) -->
                <button class="blend-action-btn secondary" id="proceed-to-blend-btn" style="display: none;">Proceed to Blend</button>
                
                <!-- Blend Weight Controls -->
                <div class="blend-weights-section" id="blend-weights-section" style="display: none;">
                    <h3>Blend Weights</h3>
                    <div class="weight-slider-container">
                        <label for="weight-slider-1">
                            <span class="weight-label">Motion 1</span>
                            <span class="weight-value" id="weight-value-1">50%</span>
                        </label>
                        <input type="range" id="weight-slider-1" class="weight-slider green-slider" 
                               min="0" max="100" value="50" data-slot="1" />
                    </div>
                    <div class="weight-slider-container">
                        <label for="weight-slider-2">
                            <span class="weight-label">Motion 2</span>
                            <span class="weight-value" id="weight-value-2">50%</span>
                        </label>
                        <input type="range" id="weight-slider-2" class="weight-slider blue-slider" 
                               min="0" max="100" value="50" data-slot="2" />
                    </div>
                    <div class="weight-slider-container" id="weight-container-3" style="display: none;">
                        <label for="weight-slider-3">
                            <span class="weight-label">Motion 3</span>
                            <span class="weight-value" id="weight-value-3">0%</span>
                        </label>
                        <input type="range" id="weight-slider-3" class="weight-slider orange-slider" 
                               min="0" max="100" value="0" data-slot="3" />
                    </div>
                    <div class="weight-normalize-info">
                        <small>Weights auto-normalize to 100%</small>
                    </div>
                </div>
                
                <button class="blend-action-btn primary" id="compute-blend-btn" disabled>Compute Blend</button>
                <div class="blend-status-indicator">Ready to select motions</div>
            </div>

            <!-- Blend Metrics Card (Bottom Left) -->
            <div id="blend-metrics-card">
                <h3>Blend Metrics</h3>
                <div class="metrics-row">
                    <span class="metric-label">Total Frames</span>
                    <span class="metric-value" id="metric-total-frames">â€”</span>
                </div>
                <div class="metrics-row">
                    <span class="metric-label">Motion Sequences</span>
                    <span class="metric-value" id="metric-sequences">â€”</span>
                </div>
                <div class="metrics-row">
                    <span class="metric-label">Duration</span>
                    <span class="metric-value" id="metric-duration">â€”</span>
                </div>
                <div class="metrics-row">
                    <span class="metric-label">Compatibility</span>
                    <span class="metric-value good" id="metric-compatibility">â€”</span>
                </div>
                <div class="compatibility-bar">
                    <div class="compatibility-fill" id="compatibility-fill" style="width: 0%"></div>
                </div>
                <div class="metrics-row">
                    <span class="metric-label">Blend Quality</span>
                    <span class="metric-value highlight" id="metric-quality">â€”</span>
                </div>
            </div>

            <!-- Animation Strips (Horizontal Timeline) -->
            <div id="animation-strips-container">
                <!-- Strip 1 - Green -->
                <div class="animation-strip" id="animation-strip-1" data-color="green">
                    <div class="strip-header">
                        <span class="strip-title">Motion 1</span>
                        <span class="strip-badge green">â—</span>
                    </div>
                    <div class="strip-timeline">
                        <div class="frame-previews" id="frame-previews-1">
                            <!-- Frame thumbnails will be inserted here via JS -->
                        </div>
                        <div class="color-shadow green-shadow"></div>
                    </div>
                </div>

                <!-- Strip 2 - Blue -->
                <div class="animation-strip" id="animation-strip-2" data-color="blue">
                    <div class="strip-header">
                        <span class="strip-title">Motion 2</span>
                        <span class="strip-badge blue">â—</span>
                    </div>
                    <div class="strip-timeline">
                        <div class="frame-previews" id="frame-previews-2">
                            <!-- Frame thumbnails will be inserted here via JS -->
                        </div>
                        <div class="color-shadow blue-shadow"></div>
                    </div>
                </div>

                <!-- Strip 3 - Orange (Optional) -->
                <div class="animation-strip" id="animation-strip-3" data-color="orange">
                    <div class="strip-header">
                        <span class="strip-title">Motion 3 (Optional)</span>
                        <span class="strip-badge orange">â—</span>
                    </div>
                    <div class="strip-timeline">
                        <div class="frame-previews" id="frame-previews-3">
                            <!-- Frame thumbnails will be inserted here via JS -->
                        </div>
                        <div class="color-shadow orange-shadow"></div>
                    </div>
                </div>

                <!-- Strip 4 - Blend Artifact -->
                <div class="animation-strip blend-output-strip" id="animation-strip-blend" data-color="blend">
                    <div class="strip-header">
                        <span class="strip-title">Blend Artifact</span>
                        <span class="strip-badge blend">â—†</span>
                        <label style="margin-left: 10px; font-size: 11px; display: inline-flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="use-gemini-analysis" style="margin-right: 4px;" />
                            <span style="color: #1a73e8;">âœ¨ AI Analysis</span>
                        </label>
                        <button class="ai-gen-btn" id="generate-artifacts-btn" disabled title="Generate blend artifact(s)">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z" fill="currentColor"/>
                            </svg>
                        </button>
                    </div>
                    <div class="strip-timeline">
                        <div class="frame-previews" id="frame-previews-blend">
                            <!-- Blended frame thumbnails will be inserted here via JS -->
                        </div>
                        <div class="color-shadow blend-output-shadow"></div>
                        <div class="blend-overlap-viz" id="blend-overlap-viz">
                            <!-- Overlapping motion sequences visualization -->
                        </div>
                    </div>
                </div>

                <!-- Blend Zones Overlay (Crosshatch patterns) -->
                <div id="blend-zones-overlay">
                    <!-- Crosshatch rectangles under each motion strip -->
                </div>
            </div>
        </div>

        <!-- Artifacts Tab Content -->
        <div id="artifacts-tab" class="tab-content">
            <!-- Animation Card (Top Left) -->
            <div id="artifacts-animation-card">
                <div class="artifacts-card-header">
                    <h3>Blend Artifact</h3>
                </div>
                <div class="artifacts-card-thumbnail" id="artifacts-thumbnail">
                    <!-- Character thumbnail will be rendered here -->
                    <div class="thumbnail-placeholder">
                        <svg width="80" height="80" viewBox="0 0 24 24" fill="#999">
                            <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"/>
                        </svg>
                    </div>
                </div>
                <div class="artifacts-card-info">
                    <div class="info-row">
                        <span class="label">Frames:</span>
                        <span class="value" id="artifacts-frame-count">--</span>
                    </div>
                    <div class="info-row">
                        <span class="label">FPS:</span>
                        <span class="value">30</span>
                    </div>
                    <div class="info-row">
                        <span class="label">Quality:</span>
                        <span class="value quality-badge" id="artifacts-quality">--</span>
                    </div>
                    <div id="gemini-insights-section" style="display:none; margin-top:10px; border-top: 1px solid #e0e0e0; padding-top: 10px;">
                        <div style="font-size: 11px; font-weight: 600; color: #1a73e8; margin-bottom: 8px;">
                            âœ¨ Gemini Analysis
                        </div>
                        <div class="info-row">
                            <span class="label">Compatibility:</span>
                            <span class="value" id="gemini-compatibility">--</span>
                        </div>
                        <div class="info-row">
                            <span class="label">Motion Types:</span>
                            <span class="value" id="gemini-motion-types" style="font-size: 10px;">--</span>
                        </div>
                        <div class="info-row">
                            <span class="label">Predicted Quality:</span>
                            <span class="value" id="gemini-predicted-quality">--</span>
                        </div>
                        <div style="font-size: 9px; color: #666; margin-top: 6px; line-height: 1.3;" id="gemini-recommendation">
                            --
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 3D Viewport (Center) -->
            <div class="artifacts-viewport">
                <canvas id="artifacts-canvas"></canvas>
                
                <!-- Playback controls -->
                <div class="playback-controls" id="artifact-playback-controls" style="display: none;">
                    <button class="play-button" id="artifact-play-pause-btn">â–¶</button>
                    <div class="timeline">
                        <input type="range" id="artifact-timeline-slider" min="0" max="100" value="0" />
                    </div>
                    <div class="frame-display" id="artifact-frame-display">Frame 0/0</div>
                </div>
            </div>
            
            <!-- Blend Artifact Strip (Bottom) - Replaces Reference -->
            <div class="artifacts-blend-output" id="artifacts-blend-output">
                <div class="blend-output-header">
                    <div class="strip-label">Blend Artifact</div>
                    <div class="blend-output-actions">
                        <label class="gemini-option">
                            <input type="checkbox" id="artifacts-use-gemini" />
                            <span>Use Gemini AI Analysis</span>
                        </label>
                        <button class="ai-gen-btn" id="artifacts-generate-btn" disabled title="Generate blend artifacts">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z" fill="currentColor"/>
                            </svg>
                            <span>Generate Artifacts</span>
                        </button>
                    </div>
                </div>
                <div class="blend-status-indicator artifacts-status" id="artifacts-status-indicator">
                    Select 2+ motions in Animations tab to begin
                </div>
                <div class="strip-timeline">
                    <div class="frame-previews" id="artifacts-blend-previews">
                        <!-- Blended frame thumbnails will be rendered here -->
                    </div>
                    <div class="color-shadow artifacts-blend-shadow"></div>
                    <div class="blend-overlap-viz" id="artifacts-blend-viz">
                        <!-- Crosshatch overlays will be shown here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
        <div class="status loading" id="status">Loading...</div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/fflate.min.js"></script>
    
    <script>
        console.log('Three.js version:', THREE.REVISION);
        console.log('FBXLoader available:', typeof THREE.FBXLoader !== 'undefined');
        console.log('OrbitControls available:', typeof THREE.OrbitControls !== 'undefined');
        
        // Michele Visualizer
        class MicheleVisualizer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.character = null;
                this.mixer = null;
                this.clock = new THREE.Clock();
                
                this.init();
            }
            
            init() {
                console.log('ðŸŽ¬ Initializing Michele Visualizer...');
                this.updateStatus('Initializing...', 'loading');
                
                // Setup scene
                this.setupScene();
                
                // Load character
                this.loadCharacter();
                
                // Start animation loop
                this.animate();
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            setupScene() {
                const container = document.getElementById('canvas-container');
                const canvas = document.getElementById('webgl-canvas');
                
                // Create scene with white background
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xffffff);
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(
                    45,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 1.6, 3);
                this.camera.lookAt(0, 1, 0);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas,
                    antialias: true 
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.near = 0.1;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -10;
                directionalLight.shadow.camera.right = 10;
                directionalLight.shadow.camera.top = 10;
                directionalLight.shadow.camera.bottom = -10;
                this.scene.add(directionalLight);
                
                // Add subtle rim light
                const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
                rimLight.position.set(-5, 5, -5);
                this.scene.add(rimLight);
                
                // Add checkerboard floor
                const floorSize = 20;
                const checkerSize = 1;
                const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
                
                // Create checkerboard texture
                const checkerCanvas = document.createElement('canvas');
                checkerCanvas.width = 128;
                checkerCanvas.height = 128;
                const ctx = checkerCanvas.getContext('2d');
                const squareSize = checkerCanvas.width / (floorSize / checkerSize);
                
                for (let i = 0; i < floorSize / checkerSize; i++) {
                    for (let j = 0; j < floorSize / checkerSize; j++) {
                        ctx.fillStyle = (i + j) % 2 === 0 ? '#e0e0e0' : '#999999';
                        ctx.fillRect(i * squareSize, j * squareSize, squareSize, squareSize);
                    }
                }
                
                const checkerTexture = new THREE.CanvasTexture(checkerCanvas);
                checkerTexture.wrapS = THREE.RepeatWrapping;
                checkerTexture.wrapT = THREE.RepeatWrapping;
                checkerTexture.repeat.set(1, 1);
                
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    map: checkerTexture,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                this.scene.add(floor);
                
                // Add orbit controls
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.target.set(0, 1, 0);
                this.controls.update();
                
                console.log('âœ… Scene setup complete');
            }
            
            loadCharacter() {
                console.log('ðŸ“¦ Loading Michele character...');
                this.updateStatus('Loading Michele...', 'loading');
                
                const loader = new THREE.FBXLoader();
                
                // Ch03_nonPBR.fbx is Michele - load it first
                const paths = [
                    '/static/models/Ch03_nonPBR.fbx',  // Michele character
                    '/static/models/michele/Michele@T-Pose.fbx',
                    '/static/models/michele/Michele.fbx',
                    '/static/models/X Bot@Capoeira.fbx'  // Fallback
                ];
                
                this.tryLoadingFromPaths(loader, paths, 0);
            }
            
            tryLoadingFromPaths(loader, paths, index) {
                if (index >= paths.length) {
                    console.error('âŒ Failed to load model from any path');
                    this.updateStatus('Please download Michele animations (see instructions)', 'error');
                    this.showDownloadInstructions();
                    return;
                }
                
                const path = paths[index];
                console.log(`Trying path: ${path}`);
                
                loader.load(
                    path,
                    (fbx) => this.onCharacterLoaded(fbx, path),
                    (xhr) => {
                        if (xhr.lengthComputable) {
                            const percent = Math.round((xhr.loaded / xhr.total) * 100);
                            console.log(`Loading ${path}: ${percent}% (${xhr.loaded}/${xhr.total} bytes)`);
                            this.updateStatus(`Loading character... ${percent}%`, 'loading');
                        } else {
                            console.log(`Loading ${path}: ${xhr.loaded} bytes`);
                        }
                    },
                    (error) => {
                        console.error(`Failed to load from ${path}:`, error);
                        console.error('Error type:', error.constructor.name);
                        console.error('Error message:', error.message);
                        console.error('Error stack:', error.stack);
                        this.tryLoadingFromPaths(loader, paths, index + 1);
                    }
                );
            }
            
            showDownloadInstructions() {
                const infoPanel = document.getElementById('info-panel');
                const instructions = document.createElement('div');
                instructions.style.marginTop = '16px';
                instructions.style.padding = '12px';
                instructions.style.background = '#fff3cd';
                instructions.style.border = '1px solid #ffc107';
                instructions.style.borderRadius = '4px';
                instructions.style.fontSize = '13px';
                instructions.innerHTML = `
                    <strong>ðŸ“¥ Download Michele Animations</strong><br>
                    <ol style="margin: 8px 0 0 20px; padding: 0;">
                        <li>Go to <a href="https://www.mixamo.com" target="_blank">mixamo.com</a></li>
                        <li>Log in with Adobe account</li>
                        <li>Open console (F12) and run download script</li>
                        <li>See MICHELE_DOWNLOAD_INSTRUCTIONS.md</li>
                    </ol>
                `;
                infoPanel.appendChild(instructions);
            }
            
            onCharacterLoaded(fbx, loadedPath) {
                console.log('âœ… Character loaded successfully from:', loadedPath);
                
                this.character = fbx;
                
                // Ch03_nonPBR.fbx is Michele
                const isMichele = loadedPath.includes('Ch03_nonPBR') || loadedPath.includes('Michele') || loadedPath.includes('michele');
                const characterName = isMichele ? 'Michele' : 'Placeholder Character';
                
                // Update UI to show Michele
                const titleEl = document.querySelector('h1');
                const modelNameEl = document.getElementById('model-name');
                
                if (titleEl) titleEl.textContent = characterName;
                if (modelNameEl) modelNameEl.textContent = `Model: ${loadedPath.split('/').pop()}`;
                
                // Scale and position character
                this.character.scale.set(0.01, 0.01, 0.01);
                this.character.position.set(0, 0, 0);
                
                // Enable shadows
                this.character.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // Ensure proper material
                        if (child.material) {
                            child.material.side = THREE.FrontSide;
                            child.material.needsUpdate = true;
                        }
                    }
                });
                
                // Add to scene
                this.scene.add(this.character);
                
                // Create animation mixer (even though we're showing T-pose)
                this.mixer = new THREE.AnimationMixer(this.character);
                
                // If there are animations, pause on first frame
                if (fbx.animations && fbx.animations.length > 0) {
                    console.log(`Found ${fbx.animations.length} animation(s)`);
                    const action = this.mixer.clipAction(fbx.animations[0]);
                    action.play();
                    action.paused = true;
                    action.time = 0;
                }
                
                // Center camera on character
                this.centerCameraOnCharacter();
                
                this.updateStatus('Ready', 'status');
                console.log('ðŸŽ¬ Michele is ready!');
                
                // Stop trying other paths - we succeeded!
                return;
            }
            
            centerCameraOnCharacter() {
                if (!this.character) return;
                
                const box = new THREE.Box3().setFromObject(this.character);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                // Update controls target
                this.controls.target.copy(center);
                
                // Position camera to see full character
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = this.camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                cameraZ *= 1.5; // Add some padding
                
                this.camera.position.set(center.x + cameraZ * 0.5, center.y + size.y * 0.3, center.z + cameraZ);
                this.camera.lookAt(center);
                this.controls.update();
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const delta = this.clock.getDelta();
                
                // Update mixer (even though paused, for proper initial pose)
                if (this.mixer) {
                    this.mixer.update(delta);
                }
                
                // Update controls
                if (this.controls) {
                    this.controls.update();
                }
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            updateStatus(message, className = 'status') {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${className}`;
            }
        }
        
        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            window.visualizer = new MicheleVisualizer();
            
            // Initialize tab switching
            initTabs();
            
            // Initialize Animations tab
            initAnimationsTab();
        });
        
        // Tab Switching Logic
        function initTabs() {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetTab = tab.dataset.tab;
                    
                    // Remove active class from all tabs
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));
                    
                    // Add active class to clicked tab
                    tab.classList.add('active');
                    document.getElementById(`${targetTab}-tab`).classList.add('active');
                    
                    console.log(`Switched to ${targetTab} tab`);
                });
            });
        }
        
        // Animations Tab Logic
        async function initAnimationsTab() {
            // Load motion library from JSON manifest
            let motions = [];
            
            try {
                const response = await fetch('/motion_library.json');
                const manifest = await response.json();
                motions = manifest.motions.map(m => ({
                    id: m.id,
                    name: m.name,
                    path: m.gemini_uri || m.local_path,
                    icon: m.icon || 'ðŸŽ­',
                    frames: m.frames || 100,
                    fps: m.fps || 30,
                    useGemini: m.use_gemini || false
                }));
                console.log(`âœ… Loaded ${motions.length} motions from manifest`);
            } catch (error) {
                console.warn('Failed to load motion manifest, using defaults:', error);
                // Fallback to hardcoded motions
                motions = [
                    {
                        id: 'capoeira',
                        name: 'Capoeira',
                        path: '/static/models/X Bot@Capoeira.fbx',
                        icon: 'ðŸ¥‹',
                        frames: 103,
                        fps: 30,
                        useGemini: false
                    },
                    {
                        id: 'breakdance',
                        name: 'Breakdance Freeze',
                        path: '/static/models/X Bot@Breakdance Freeze Var 2.fbx',
                        icon: 'ðŸ•º',
                        frames: 120,
                        fps: 30,
                        useGemini: false
                    }
                ];
            }
            
            const motionGrid = document.getElementById('motion-grid');
            const animationsCanvas = document.getElementById('animations-canvas');
            const playbackControls = document.getElementById('playback-controls');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const timelineSlider = document.getElementById('timeline-slider');
            const frameDisplay = document.getElementById('frame-display');
            const searchInput = document.getElementById('motion-search');
            
            console.log('ðŸ“‹ Elements found:', {
                motionGrid: !!motionGrid,
                animationsCanvas: !!animationsCanvas,
                playbackControls: !!playbackControls
            });
            
            let currentScene = null;
            let currentCamera = null;
            let currentRenderer = null;
            let currentControls = null;
            let currentMixer = null;
            let currentAction = null;
            let currentClock = new THREE.Clock();
            let isPlaying = false;
            let animationDuration = 0;
            
            // Populate motion cards
            function renderMotionCards(filter = '') {
                motionGrid.innerHTML = '';
                const filteredMotions = motions.filter(m => 
                    m.name.toLowerCase().includes(filter.toLowerCase())
                );
                
                console.log(`ðŸŽ¬ Rendering ${filteredMotions.length} motion cards`);
                
                filteredMotions.forEach(motion => {
                    const card = document.createElement('div');
                    card.className = 'motion-card';
                    card.innerHTML = `
                        <div class="motion-thumbnail" id="thumb-${motion.id}">
                            <div class="loading-indicator">Loading preview...</div>
                        </div>
                        <div class="motion-info">
                            <div class="motion-name">${motion.name}</div>
                            <div class="motion-details" id="motion-details-${motion.id}">${motion.frames} frames â€¢ ${motion.fps} fps</div>
                            <div class="trimming-controls" id="trim-${motion.id}">
                                <div class="trim-range-container">
                                    <div class="trim-range-label">
                                        <span>Trim Range: </span>
                                        <span id="trim-range-${motion.id}">0 - ${motion.frames - 1}</span>
                                        <span class="trim-frame-count">(${motion.frames} frames)</span>
                                    </div>
                                    <div class="trim-range-slider">
                                        <input type="range" id="trim-start-${motion.id}" class="trim-range-input trim-start" min="0" max="${motion.frames - 1}" value="0" />
                                        <input type="range" id="trim-end-${motion.id}" class="trim-range-input trim-end" min="0" max="${motion.frames - 1}" value="${motion.frames - 1}" />
                                        <div class="trim-range-track"></div>
                                    </div>
                                </div>
                                <div class="trim-info">
                                    <small>Trimmed: <span id="trimmed-frames-${motion.id}">${motion.frames}</span> frames</small>
                                </div>
                            </div>
                        </div>
                        <div class="blend-flags">
                            <button class="flag-btn green" data-motion-id="${motion.id}" data-slot="1" title="Add to Blend Slot 1">â—</button>
                            <button class="flag-btn blue" data-motion-id="${motion.id}" data-slot="2" title="Add to Blend Slot 2">â—</button>
                            <button class="flag-btn orange" data-motion-id="${motion.id}" data-slot="3" title="Add to Blend Slot 3">â—</button>
                        </div>
                    `;
                    card.addEventListener('click', (e) => {
                        // Don't load motion if clicking a flag button
                        if (!e.target.classList.contains('flag-btn')) {
                            loadMotion(motion, card);
                        }
                    });
                    motionGrid.appendChild(card);
                    
                    console.log(`âœ… Created card for: ${motion.name}`);
                    
                    // Generate preview thumbnail
                    generateThumbnail(motion);
                    
                    // Add flag button click handlers
                    const flagBtns = card.querySelectorAll('.flag-btn');
                    flagBtns.forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const slot = btn.dataset.slot;
                            handleFlagClick(motion, slot, btn);
                        });
                    });
                    
                    // Add trimming range slider event handlers
                    const trimStart = card.querySelector(`#trim-start-${motion.id}`);
                    const trimEnd = card.querySelector(`#trim-end-${motion.id}`);
                    const trimRange = card.querySelector(`#trim-range-${motion.id}`);
                    const trimmedFrames = card.querySelector(`#trimmed-frames-${motion.id}`);
                    
                    if (trimStart && trimEnd) {
                        // Store motion data for viewport updates
                        motion.trimStart = 0;
                        motion.trimEnd = motion.frames - 1;
                        
                        const updateTrimRange = () => {
                            const startFrame = parseInt(trimStart.value);
                            const endFrame = parseInt(trimEnd.value);
                            
                            // Ensure start doesn't exceed end
                            if (startFrame >= endFrame) {
                                trimStart.value = Math.max(0, endFrame - 1);
                                return;
                            }
                            
                            // Update motion trim data
                            motion.trimStart = startFrame;
                            motion.trimEnd = endFrame;
                            
                            // Update display
                            trimRange.textContent = `${startFrame} - ${endFrame}`;
                            updateTrimmedFrames(startFrame, endFrame, trimmedFrames);
                            
                            // Update 3D viewport if this motion is currently loaded
                            updateViewportTrimRange(motion);
                            
                            // Regenerate thumbnail for trimmed range
                            generateTrimmedThumbnail(motion, startFrame, endFrame);
                        };
                        
                        // Handle start slider
                        trimStart.addEventListener('input', updateTrimRange);
                        
                        // Handle end slider
                        trimEnd.addEventListener('input', updateTrimRange);
                        
                        // Update track visualization
                        const updateTrack = () => {
                            const startPercent = (parseInt(trimStart.value) / (motion.frames - 1)) * 100;
                            const endPercent = (parseInt(trimEnd.value) / (motion.frames - 1)) * 100;
                            const track = card.querySelector('.trim-range-track');
                            if (track) {
                                track.style.background = `linear-gradient(to right, #e0e0e0 0%, #e0e0e0 ${startPercent}%, #FF6700 ${startPercent}%, #FF6700 ${endPercent}%, #e0e0e0 ${endPercent}%, #e0e0e0 100%)`;
                            }
                        };
                        
                        trimStart.addEventListener('input', updateTrack);
                        trimEnd.addEventListener('input', updateTrack);
                        
                        // Initialize track
                        updateTrack();
                    }
                });
            }
            
            // Generate thumbnail preview for motion
            // Global state for blend tab (make globally accessible for artifacts viewer)
            window.blendState = {
                slots: {
                    1: null,  // { motion, btn }
                    2: null,
                    3: null
                },
                // Store actual animation frame counts
                frameCounts: {
                    1: 0,
                    2: 0,
                    3: 0
                },
                // Store thumbnail counts for accurate crosshatch width
                thumbnailCounts: {
                    1: 0,
                    2: 0,
                    3: 0
                },
                // Store crosshatch position offsets (0-1 range, 0 = start)
                crosshatchOffsets: {
                    1: 0,
                    2: 0,
                    3: 0
                }
            };
            
            // Setup drag and drop for motion slot reordering
            function setupSlotDragAndDrop() {
                const slots = document.querySelectorAll('.selected-motion-slot');
                
                slots.forEach(slot => {
                    slot.setAttribute('draggable', 'true');
                    
                    slot.addEventListener('dragstart', (e) => {
                        if (!blendState.slots[slot.dataset.slot]) return;
                        slot.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', slot.dataset.slot);
                    });
                    
                    slot.addEventListener('dragend', () => {
                        slot.classList.remove('dragging');
                    });
                    
                    slot.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        slot.classList.add('drag-over');
                    });
                    
                    slot.addEventListener('dragleave', () => {
                        slot.classList.remove('drag-over');
                    });
                    
                    slot.addEventListener('drop', (e) => {
                        e.preventDefault();
                        slot.classList.remove('drag-over');
                        
                        const fromSlot = parseInt(e.dataTransfer.getData('text/plain'));
                        const toSlot = parseInt(slot.dataset.slot);
                        
                        if (fromSlot !== toSlot) {
                            // Swap ALL state data
                            const tempSlot = blendState.slots[fromSlot];
                            const tempFrameCount = blendState.frameCounts[fromSlot];
                            const tempThumbnailCount = blendState.thumbnailCounts[fromSlot];
                            const tempOffset = blendState.crosshatchOffsets[fromSlot];
                            
                            blendState.slots[fromSlot] = blendState.slots[toSlot];
                            blendState.frameCounts[fromSlot] = blendState.frameCounts[toSlot];
                            blendState.thumbnailCounts[fromSlot] = blendState.thumbnailCounts[toSlot];
                            blendState.crosshatchOffsets[fromSlot] = blendState.crosshatchOffsets[toSlot];
                            
                            blendState.slots[toSlot] = tempSlot;
                            blendState.frameCounts[toSlot] = tempFrameCount;
                            blendState.thumbnailCounts[toSlot] = tempThumbnailCount;
                            blendState.crosshatchOffsets[toSlot] = tempOffset;
                            
                            // Update flag buttons in animations tab
                            updateFlagButtonsAfterSwap(fromSlot, toSlot);
                            
                            // Update slot displays
                            updateAllSlotDisplays();
                            
                            // Swap the actual thumbnail strips (DOM swap, no regeneration)
                            swapBlendStrips(fromSlot, toSlot);
                            
                            // Update crosshatch visualization
                            updateCrosshatchOverlap();
                            
                            console.log(`ðŸ”„ Swapped slot ${fromSlot} â†” slot ${toSlot}`);
                        }
                    });
                });
            }
            
            // Update all slot displays after reordering
            function updateAllSlotDisplays() {
                for (let slot = 1; slot <= 3; slot++) {
                    updateBlendSlot(slot, blendState.slots[slot]?.motion || null);
                }
            }
            
            // Swap blend strip thumbnails in DOM without regenerating
            function swapBlendStrips(fromSlot, toSlot) {
                const fromContainer = document.getElementById(`frame-previews-${fromSlot}`);
                const toContainer = document.getElementById(`frame-previews-${toSlot}`);
                
                if (!fromContainer || !toContainer) return;
                
                // Swap innerHTML (thumbnails)
                const tempHTML = fromContainer.innerHTML;
                fromContainer.innerHTML = toContainer.innerHTML;
                toContainer.innerHTML = tempHTML;
                
                // Swap crosshatch elements
                const fromCrosshatch = fromContainer.nextElementSibling;
                const toCrosshatch = toContainer.nextElementSibling;
                
                if (fromCrosshatch && toCrosshatch && 
                    fromCrosshatch.classList.contains('color-shadow') && 
                    toCrosshatch.classList.contains('color-shadow')) {
                    
                    // Swap widths and positions
                    const tempWidth = fromCrosshatch.style.width;
                    const tempLeft = fromCrosshatch.style.left;
                    
                    fromCrosshatch.style.width = toCrosshatch.style.width;
                    fromCrosshatch.style.left = toCrosshatch.style.left;
                    
                    toCrosshatch.style.width = tempWidth;
                    toCrosshatch.style.left = tempLeft;
                }
                
                console.log(`âœ… Swapped DOM elements for slots ${fromSlot} and ${toSlot}`);
            }
            
            // Update flag buttons after slot swap
            function updateFlagButtonsAfterSwap(fromSlot, toSlot) {
                // Clear all active flags for both slots
                document.querySelectorAll(`.flag-btn[data-slot="${fromSlot}"]`).forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelectorAll(`.flag-btn[data-slot="${toSlot}"]`).forEach(btn => {
                    btn.classList.remove('active');
                });
                
                // Re-activate correct flags
                if (blendState.slots[fromSlot]) {
                    const motionId = blendState.slots[fromSlot].motion.id;
                    const flagBtn = document.querySelector(`.flag-btn[data-motion-id="${motionId}"][data-slot="${fromSlot}"]`);
                    if (flagBtn) {
                        flagBtn.classList.add('active');
                        blendState.slots[fromSlot].btn = flagBtn;
                    }
                }
                
                if (blendState.slots[toSlot]) {
                    const motionId = blendState.slots[toSlot].motion.id;
                    const flagBtn = document.querySelector(`.flag-btn[data-motion-id="${motionId}"][data-slot="${toSlot}"]`);
                    if (flagBtn) {
                        flagBtn.classList.add('active');
                        blendState.slots[toSlot].btn = flagBtn;
                    }
                }
                
                console.log('âœ… Updated flag buttons after swap');
            }
            
            // Normalize weights to total 100%
            function normalizeWeights() {
                const sliders = [1, 2, 3].map(i => document.getElementById(`weight-slider-${i}`));
                const values = sliders.map(s => parseFloat(s.value) || 0);
                const total = values.reduce((a, b) => a + b, 0);
                
                if (total === 0) return;
                
                // Normalize to 100%
                const normalized = values.map(v => (v / total) * 100);
                
                sliders.forEach((slider, i) => {
                    if (slider && !slider.disabled) {
                        slider.value = normalized[i].toFixed(0);
                        const valueDisplay = document.getElementById(`weight-value-${i + 1}`);
                        if (valueDisplay) {
                            valueDisplay.textContent = `${normalized[i].toFixed(0)}%`;
                        }
                    }
                });
            }
            
            // Add weight slider listeners for normalization
            function setupWeightSliders() {
                for (let slot = 1; slot <= 3; slot++) {
                    const slider = document.getElementById(`weight-slider-${slot}`);
                    const valueDisplay = document.getElementById(`weight-value-${slot}`);
                    
                    if (slider) {
                        slider.addEventListener('input', (e) => {
                            valueDisplay.textContent = `${e.target.value}%`;
                            normalizeWeights();
                            updateCrosshatchOverlap();
                        });
                    }
                }
            }
            
            // Setup draggable crosshatch for frame selection
            let activeDrag = null; // Track which crosshatch is being dragged

            function setupCrosshatchDragging() {
                // Add global mouse handlers once
                document.addEventListener('mousemove', (e) => {
                    if (!activeDrag) return;

                    const { slot, crosshatch, frameContainer, startX, startLeft, isArtifacts } = activeDrag;

                    const containerWidth = frameContainer.offsetWidth;
                    const crosshatchWidth = crosshatch.offsetWidth;
                    const maxLeft = Math.max(0, containerWidth - crosshatchWidth);

                    const deltaX = e.clientX - startX;
                    let newLeft = startLeft + deltaX;

                    // For blend tab: clamp to container bounds with centered positioning
                    if (!activeDrag.isArtifacts) {
                        // Allow full range positioning for blend tab (can adjust start position)
                        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                        
                        // Update blend state for blend tab
                        blendState.crosshatchOffsets[slot] = offset;

                        // Update frame count labels during drag
                        const totalFrames = blendState.frameCounts[slot] || 0;
                        const weightSlider = document.getElementById(`weight-slider-${slot}`);
                        const weight = weightSlider ? parseFloat(weightSlider.value) / 100 : 0;
                        const framesToBlend = Math.round(totalFrames * weight);
                        updateFrameCountLabels(slot, crosshatch, totalFrames, framesToBlend, offset);

                        console.log(`Slot ${slot} crosshatch at ${(offset * 100).toFixed(0)}% (${newLeft.toFixed(0)}px / ${maxLeft.toFixed(0)}px)`);
                    } else {
                        // For artifacts tab: keep centered positioning
                        const containerCenter = containerWidth / 2;
                        const crosshatchCenter = crosshatchWidth / 2;
                        const centeredLeft = containerCenter - crosshatchCenter;
                        newLeft = Math.max(0, Math.min(centeredLeft, maxLeft));
                        
                        // For artifacts tab, update timeline position
                        const artifactsViewer = window.artifactsViewer;
                        if (artifactsViewer && artifactsViewer.sequenceData) {
                            const totalFrames = artifactsViewer.sequenceData.length;
                            const frameIndex = Math.round(offset * (totalFrames - 1));
                            artifactsViewer.updateFrame(frameIndex);

                            // Update timeline slider
                            const timeline = document.getElementById('artifact-timeline-slider');
                            if (timeline) {
                                timeline.value = frameIndex;
                            }

                            console.log(`Artifacts crosshatch at ${(offset * 100).toFixed(0)}% (frame ${frameIndex}/${totalFrames})`);
                        }
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (activeDrag) {
                        activeDrag.crosshatch.classList.remove('dragging');
                        activeDrag = null;
                    }
                });

                // Attach mousedown to blend tab crosshatch elements
                for (let slot = 1; slot <= 3; slot++) {
                    const frameContainer = document.getElementById(`frame-previews-${slot}`);
                    if (!frameContainer) continue;

                    const crosshatch = frameContainer.nextElementSibling;
                    if (!crosshatch || !crosshatch.classList.contains('color-shadow')) continue;

                    crosshatch.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        crosshatch.classList.add('dragging');

                        activeDrag = {
                            slot: slot,
                            crosshatch: crosshatch,
                            frameContainer: frameContainer,
                            startX: e.clientX,
                            startLeft: parseFloat(crosshatch.style.left || '0'),
                            isArtifacts: false
                        };

                        console.log(`ðŸŽ¯ Started dragging blend slot ${slot} crosshatch`);
                    });
                }

                // Attach mousedown to artifacts tab crosshatch elements
                const artifactsOverlapViz = document.getElementById('artifacts-overlap-viz');
                if (artifactsOverlapViz) {
                    const artifactsFramePreviews = document.getElementById('artifacts-frame-previews');

                    // Attach to all crosshatch overlay segments in artifacts tab
                    const crosshatchElements = artifactsOverlapViz.querySelectorAll('.overlap-segment');
                    crosshatchElements.forEach((crosshatch, index) => {
                        crosshatch.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            crosshatch.classList.add('dragging');

                            activeDrag = {
                                slot: index, // Use index for artifacts crosshatch
                                crosshatch: crosshatch,
                                frameContainer: artifactsFramePreviews,
                                startX: e.clientX,
                                startLeft: parseFloat(crosshatch.style.left || '0'),
                                isArtifacts: true
                            };

                            console.log(`ðŸŽ¯ Started dragging artifacts crosshatch segment ${index}`);
                        });
                    });
                }
            }
            
            // Update crosshatch overlap visualization based on weights
            function updateCrosshatchOverlap() {
                const selectedCount = Object.values(blendState.slots).filter(s => s !== null).length;
                if (selectedCount < 2) return;
                
                // Calculate frame counts for each motion based on weights
                for (let slot = 1; slot <= 3; slot++) {
                    if (blendState.slots[slot]) {
                        const weightSlider = document.getElementById(`weight-slider-${slot}`);
                        const weight = weightSlider ? parseFloat(weightSlider.value) / 100 : 0;
                        
                        // Use ACTUAL animation frame count, not thumbnail count
                        const totalFrames = blendState.frameCounts[slot] || 0;
                        const framesToBlend = Math.round(totalFrames * weight);
                        
                        // Update crosshatch width to represent percentage relative to thumbnails
                        const frameContainer = document.getElementById(`frame-previews-${slot}`);
                        const crosshatch = frameContainer?.nextElementSibling;
                        if (crosshatch && crosshatch.classList.contains('color-shadow')) {
                            // Use stored thumbnail count for accurate calculation
                            const totalThumbnails = blendState.thumbnailCounts[slot] || 0;
                            const thumbnailsToTake = Math.round(totalThumbnails * weight);
                            
                            // Crosshatch width = proportion of thumbnails (100% thumbnails = 100% frame count)
                            const containerWidth = frameContainer.offsetWidth;
                            const crosshatchWidth = totalThumbnails > 0 ? (thumbnailsToTake / totalThumbnails) * containerWidth : containerWidth * weight;
                            crosshatch.style.width = `${crosshatchWidth}px`;
                            
                            // Position crosshatch centered at the midpoint of its possible range
                            // The midpoint of the crosshatch should align with the center of the container
                            const containerCenter = containerWidth / 2;
                            const crosshatchCenter = crosshatchWidth / 2;
                            const centeredLeft = containerCenter - crosshatchCenter;
                            
                            // Clamp to valid range (crosshatch can't go outside container)
                            const maxLeft = Math.max(0, containerWidth - crosshatchWidth);
                            const clampedLeft = Math.max(0, Math.min(centeredLeft, maxLeft));
                            
                            crosshatch.style.left = `${clampedLeft}px`;
                            
                            // Store the effective offset (0-1) based on centered position
                            const effectiveOffset = maxLeft > 0 ? clampedLeft / maxLeft : 0;
                            blendState.crosshatchOffsets[slot] = effectiveOffset;
                            
                            console.log(`Slot ${slot}: ${thumbnailsToTake}/${totalThumbnails} thumbnails = ${framesToBlend}/${totalFrames} frames (${(weight*100).toFixed(0)}%)`);
                        }
                        
                        // Update slot name to show frame count
                        const slotNameEl = document.querySelector(`.selected-motion-slot[data-slot="${slot}"] .slot-name`);
                        if (slotNameEl && blendState.slots[slot]) {
                            slotNameEl.textContent = `${blendState.slots[slot].motion.name} (${framesToBlend} frames)`;
                        }
                        
                        console.log(`Slot ${slot}: ${framesToBlend}/${totalFrames} frames (${(weight * 100).toFixed(0)}%)`);
                    }
                }
            }
            
            // Update frame count labels on crosshatch
            function updateFrameCountLabels(slot, crosshatch, totalFrames, framesToBlend, offset) {
                // Calculate start and end frame numbers
                const maxStartFrame = totalFrames - framesToBlend;
                const startFrame = Math.round(maxStartFrame * offset);
                const endFrame = startFrame + framesToBlend;
                
                // Remove existing labels
                const existingLabels = crosshatch.querySelectorAll('.crosshatch-frame-label');
                existingLabels.forEach(label => label.remove());
                
                // Create start label
                const startLabel = document.createElement('div');
                startLabel.className = 'crosshatch-frame-label start';
                startLabel.textContent = `${startFrame}`;
                crosshatch.appendChild(startLabel);
                
                // Create end label
                const endLabel = document.createElement('div');
                endLabel.className = 'crosshatch-frame-label end';
                endLabel.textContent = `${endFrame}`;
                crosshatch.appendChild(endLabel);
            }
            
            // Handle flag button click
            function handleFlagClick(motion, slot, btn) {
                console.log(`ðŸ´ Flag clicked: ${motion.name} â†’ Slot ${slot}`);
                
                // Toggle active state
                const wasActive = btn.classList.contains('active');
                
                // Clear slot if was active
                if (wasActive) {
                    btn.classList.remove('active');
                    blendState.slots[slot] = null;
                    blendState.frameCounts[slot] = 0;
                    blendState.thumbnailCounts[slot] = 0;
                    blendState.crosshatchOffsets[slot] = 0;
                    updateBlendSlot(slot, null);
                    clearBlendStripThumbnails(slot);
                } else {
                    // Deactivate other flags for this slot
                    document.querySelectorAll(`.flag-btn[data-slot="${slot}"]`).forEach(b => {
                        b.classList.remove('active');
                    });
                    
                    // Activate this flag
                    btn.classList.add('active');
                    blendState.slots[slot] = { motion, btn };
                    updateBlendSlot(slot, motion);
                    generateBlendStripThumbnails(motion, slot);
                }
                
                // Update blend controls visibility
                updateBlendControls();
            }
            
            // Update blend slot display
            function updateBlendSlot(slot, motion) {
                const slotEl = document.querySelector(`.selected-motion-slot[data-slot="${slot}"]`);
                const nameEl = slotEl.querySelector('.slot-name');
                const stripTitle = document.querySelector(`#animation-strip-${slot} .strip-title`);
                
                if (motion) {
                    nameEl.textContent = motion.name;
                    stripTitle.textContent = motion.name;
                } else {
                    nameEl.textContent = 'Empty';
                    stripTitle.textContent = `Motion ${slot}`;
                }
            }
            
            // Update blend controls based on selected motions
            function updateBlendControls() {
                const selectedCount = Object.values(blendState.slots).filter(s => s !== null).length;
                const weightsSection = document.getElementById('blend-weights-section');
                const computeBtn = document.getElementById('compute-blend-btn');
                const proceedBtn = document.getElementById('proceed-to-blend-btn');
                const artifactsGenerateBtn = document.getElementById('artifacts-generate-btn');
                const artifactsStatus = document.getElementById('artifacts-status-indicator');
                const weightContainer3 = document.getElementById('weight-container-3');
                
                if (selectedCount >= 2) {
                    weightsSection.style.display = 'none'; // Hide weights for new architecture
                    computeBtn.style.display = 'none'; // Hide compute button
                    proceedBtn.style.display = 'block'; // Show proceed button
                    
                    // Enable artifacts generate button
                    if (artifactsGenerateBtn) {
                        artifactsGenerateBtn.disabled = false;
                    }
                    
                    // Update artifacts status
                    if (artifactsStatus) {
                        artifactsStatus.textContent = `${selectedCount} motions selected â€¢ Ready to blend`;
                        artifactsStatus.style.background = '#d4edda';
                        artifactsStatus.style.color = '#155724';
                    }
                    
                    // Show 3rd weight slider if 3 motions selected (though weights are hidden)
                    if (selectedCount === 3) {
                        weightContainer3.style.display = 'block';
                    } else {
                        weightContainer3.style.display = 'none';
                    }
                } else {
                    // No motions or only 1 motion selected
                    weightsSection.style.display = 'none';
                    computeBtn.style.display = 'none';
                    proceedBtn.style.display = 'none';
                    
                    // Disable artifacts generate button
                    if (artifactsGenerateBtn) {
                        artifactsGenerateBtn.disabled = true;
                    }
                    
                    // Update artifacts status
                    if (artifactsStatus) {
                        artifactsStatus.textContent = 'Select 2+ motions in Animations tab to begin';
                        artifactsStatus.style.background = '#fff3cd';
                        artifactsStatus.style.color = '#856404';
                    }
                }
            }
            
            // Compute blend button handler (just generate preview)
            document.getElementById('compute-blend-btn').addEventListener('click', async () => {
                console.log('ðŸŽ¨ Computing blend preview...');
                
                const container = document.getElementById('frame-previews-blend');
                const statusIndicator = document.querySelector('.blend-status-indicator');
                const generateArtifactsBtn = document.getElementById('generate-artifacts-btn');
                
                // Show loading state
                container.innerHTML = '<div style="padding: 40px; text-align: center; color: #666; font-size: 14px;">Computing blend...</div>';
                statusIndicator.textContent = 'Generating blend preview...';
                statusIndicator.style.background = '#fff3cd';
                
                // Get selected motions and weights
                const selectedMotions = [];
                for (let slot = 1; slot <= 3; slot++) {
                    if (blendState.slots[slot]) {
                        const weightSlider = document.getElementById(`weight-slider-${slot}`);
                        const weight = weightSlider ? parseFloat(weightSlider.value) / 100 : 0;
                        selectedMotions.push({
                            slot,
                            motion: blendState.slots[slot].motion,
                            weight,
                            actualFrameCount: blendState.frameCounts[slot] || 0,
                            frameContainer: document.getElementById(`frame-previews-${slot}`)
                        });
                    }
                }
                
                console.log('Selected motions:', selectedMotions);
                
                try {
                    // Render preview in blend output
                    await renderBlendPreview(selectedMotions, container);
                    
                    // Update status
                    statusIndicator.textContent = 'Blend preview ready - click "Generate Artifacts" to create transition frames';
                    statusIndicator.style.background = '#d4edda';
                    statusIndicator.style.color = '#155724';
                    
                    // Enable Generate Artifacts button
                    generateArtifactsBtn.disabled = false;
                    
                    // Store current selection for artifacts generation
                    blendState.currentBlendSelection = selectedMotions;
                    
                } catch (error) {
                    console.error('âŒ Blend preview failed:', error);
                    statusIndicator.textContent = `Error: ${error.message}`;
                    statusIndicator.style.background = '#f8d7da';
                    statusIndicator.style.color = '#721c24';
                    
                    container.innerHTML = `<div style="padding: 40px; text-align: center; color: #d32f2f; font-size: 14px;">
                        Failed to generate blend preview: ${error.message}
                    </div>`;
                    
                    generateArtifactsBtn.disabled = true;
                }
            });
            
            // Generate Artifacts button handler (new)
            document.getElementById('generate-artifacts-btn').addEventListener('click', async () => {
                console.log('ðŸŽ¬ Generating transition artifacts...');
                
                const statusIndicator = document.querySelector('.blend-status-indicator');
                const selectedMotions = blendState.currentBlendSelection;
                const generateBtn = document.getElementById('generate-artifacts-btn');
                const blendContainer = document.getElementById('frame-previews-blend');
                const useGemini = document.getElementById('use-gemini-analysis').checked;
                
                if (!selectedMotions || selectedMotions.length < 2) {
                    alert('Please compute blend preview first');
                    return;
                }
                
                // Add circular spinner to button
                generateBtn.classList.add('generating');
                generateBtn.disabled = true;
                
                statusIndicator.textContent = useGemini 
                    ? 'âœ¨ Analyzing motions with Gemini AI...' 
                    : 'Generating transition artifacts with BlendAnim...';
                statusIndicator.style.background = '#fff3cd';
                
                try {
                    // Prepare API request with actual frame counts from Animations tab
                    const motion_paths = selectedMotions.map(m => m.motion.path);
                    const weights = selectedMotions.map(m => m.weight);
                    const crosshatch_offsets = selectedMotions.map(m => blendState.crosshatchOffsets[m.slot] || 0);
                    const actual_frame_counts = selectedMotions.map(m => m.actualFrameCount);
                    
                    // Choose API endpoint based on Gemini checkbox
                    const apiEndpoint = useGemini ? '/api/artifacts/generate-intelligent' : '/api/artifacts/generate';
                    
                    console.log(`ðŸ“¤ Sending to ${useGemini ? 'Gemini-powered' : 'standard'} BlendAnim API:`, { 
                        motion_paths, 
                        weights, 
                        crosshatch_offsets,
                        actual_frame_counts 
                    });
                    
                    // Call artifacts API
                    const requestBody = {
                        motion_paths,
                        weights,
                        crosshatch_offsets,
                        actual_frame_counts,
                        blend_mode: 'smoothstep',
                        transition_frames: 30
                    };
                    
                    // Add Gemini-specific params if enabled
                    if (useGemini) {
                        requestBody.use_gemini_analysis = true;
                        requestBody.frame_sample_rate = 5;
                    }
                    
                    const response = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Artifact generation failed');
                    }
                    
                    const result = await response.json();
                    console.log('âœ… Artifacts generated:', result);
                    
                    // If Gemini analysis was used, log insights
                    if (result.gemini_analysis) {
                        console.log('âœ¨ Gemini Insights:');
                        console.log(`  Compatibility: ${(result.gemini_analysis.compatibility_score * 100).toFixed(1)}%`);
                        console.log(`  Motion Types: ${result.gemini_analysis.motion_a_type} â†’ ${result.gemini_analysis.motion_b_type}`);
                        console.log(`  Predicted Smoothness: ${(result.gemini_analysis.quality_prediction.predicted_smoothness * 100).toFixed(1)}%`);
                        console.log(`  Recommendation: ${result.gemini_analysis.overall_recommendation}`);
                    }
                    
                    // Store artifact data in blend state
                    blendState.currentArtifacts = result;
                    
                    // Remove spinner from button
                    generateBtn.classList.remove('generating');
                    
                    // Calculate breakdown: total frames = motion segments + transitions
                    const totalFrames = result.artifacts.length;
                    const transitionFrames = result.total_transitions * result.transition_frames_each;
                    const motionFrames = totalFrames - transitionFrames;
                    
                    // Verify frame count against expected allocation
                    let expectedMotionFrames = 0;
                    console.log('ðŸ“¦ Motion segments details:');
                    for (const segment of result.motion_segments) {
                        console.log(`  Motion ${segment.motion_index + 1}: ${segment.frame_count} frames (weight: ${segment.weight.toFixed(2)}, offset: ${segment.crosshatch_offset.toFixed(2)})`);
                        expectedMotionFrames += segment.frame_count;
                    }
                    const expectedTotal = expectedMotionFrames + transitionFrames;
                    
                    console.log('ðŸ“Š Frame verification:');
                    console.log(`  Total: ${totalFrames} (expected: ${expectedTotal})`);
                    console.log(`  Motion: ${motionFrames} (expected: ${expectedMotionFrames})`);
                    console.log(`  Transitions: ${transitionFrames}`);
                    console.log(`  Match: ${totalFrames === expectedTotal ? 'âœ“' : 'âœ— MISMATCH'}`);
                    
                    if (totalFrames !== expectedTotal) {
                        console.warn(`âš ï¸ Frame count mismatch! Expected ${expectedTotal}, got ${totalFrames}`);
                        console.warn(`  Motion segments sum: ${expectedMotionFrames}, but totalFrames - transitions = ${motionFrames}`);
                    }
                    
                    // Update status with detailed breakdown and verification
                    const verifyIcon = totalFrames === expectedTotal ? 'âœ“' : 'âš ';
                    statusIndicator.textContent = `${verifyIcon} ${totalFrames} frames (${motionFrames} motion + ${transitionFrames} blend)`;
                    statusIndicator.style.background = '#d4edda';
                    statusIndicator.style.color = '#155724';
                    
                    // Wait 3 seconds before showing artifacts (processing delay)
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    
                    // Ensure viewer is initialized before loading
                    if (!artifactsViewer) {
                        console.warn('âš ï¸ Viewer not ready, initializing now...');
                        initArtifactsViewer();
                    }
                    
                    // Load artifacts in viewer
                    await loadArtifactsInViewer(result);
                    console.log('âœ… Artifacts loaded in viewer');
                    
                    // Show floating success popup
                    showArtifactsSuccessPopup(result);
                    
                } catch (error) {
                    console.error('âŒ Artifact generation failed:', error);
                    
                    // Remove spinner from button
                    generateBtn.classList.remove('generating');
                    
                    // Show floating error popup
                    showArtifactsErrorPopup(error.message);
                    
                    statusIndicator.textContent = `Error: ${error.message}`;
                    statusIndicator.style.background = '#f8d7da';
                    statusIndicator.style.color = '#721c24';
                } finally {
                    // Re-enable button and remove spinner
                    generateBtn.classList.remove('generating');
                    generateBtn.disabled = false;
                }
            });
            
            // Proceed to Blend button handler
            document.getElementById('proceed-to-blend-btn').addEventListener('click', async () => {
                console.log('ðŸš€ Proceeding to blend with trimmed motions...');
                
                const statusIndicator = document.querySelector('.blend-status-indicator');
                const proceedBtn = document.getElementById('proceed-to-blend-btn');
                const metricsCard = document.getElementById('blend-metrics-card');
                
                // Collect trimmed motion data
                const trimmedMotions = [];
                for (let slot = 1; slot <= 3; slot++) {
                    if (blendState.slots[slot]) {
                        const motion = blendState.slots[slot].motion;
                        const startSlider = document.getElementById(`start-slider-${motion.id}`);
                        const endSlider = document.getElementById(`end-slider-${motion.id}`);
                        
                        if (startSlider && endSlider) {
                            const startFrame = parseInt(startSlider.value);
                            const endFrame = parseInt(endSlider.value);
                            const trimmedFrameCount = endFrame - startFrame + 1;
                            
                            trimmedMotions.push({
                                slot,
                                motion,
                                startFrame,
                                endFrame,
                                trimmedFrameCount,
                                originalFrameCount: motion.frames
                            });
                            
                            console.log(`âœ‚ï¸ Motion ${slot}: ${motion.name} trimmed ${startFrame}-${endFrame} (${trimmedFrameCount} frames)`);
                        }
                    }
                }
                
                if (trimmedMotions.length < 2) {
                    alert('Need at least 2 trimmed motions to proceed');
                    return;
                }
                
                // Show loading state
                proceedBtn.disabled = true;
                proceedBtn.textContent = 'Processing...';
                statusIndicator.textContent = 'Generating blend strips from trimmed motions...';
                statusIndicator.style.background = '#fff3cd';
                
                try {
                    // Generate blend strips with trimmed thumbnails
                    for (const trimmedMotion of trimmedMotions) {
                        await generateTrimmedBlendStrip(trimmedMotion);
                    }
                    
                    // Calculate blend metrics
                    const metrics = calculateBlendMetrics(trimmedMotions);
                    console.log('ðŸ“Š Blend Metrics:', metrics);
                    
                    // Display metrics in the metrics card
                    document.getElementById('metric-total-frames').textContent = metrics.totalFrames;
                    document.getElementById('metric-sequences').textContent = `${metrics.sequenceCount} motions`;
                    document.getElementById('metric-duration').textContent = `${metrics.duration.toFixed(2)}s`;
                    document.getElementById('metric-compatibility').textContent = `${metrics.compatibility}%`;
                    document.getElementById('compatibility-fill').style.width = `${metrics.compatibility}%`;
                    document.getElementById('metric-quality').textContent = metrics.qualityTier;
                    
                    // Show metrics card with animation
                    metricsCard.classList.add('visible');
                    
                    // Update compatibility color based on score
                    const compatEl = document.getElementById('metric-compatibility');
                    if (metrics.compatibility >= 80) {
                        compatEl.className = 'metric-value good';
                    } else if (metrics.compatibility >= 60) {
                        compatEl.className = 'metric-value warning';
                    } else {
                        compatEl.className = 'metric-value';
                    }
                    
                    // Update status
                    statusIndicator.textContent = `âœ“ Ready to blend ${trimmedMotions.length} trimmed motions`;
                    statusIndicator.style.background = '#d4edda';
                    statusIndicator.style.color = '#155724';
                    
                    // Show blend controls for smoothstep adjustment
                    showBlendControlsForTrimmedMotions(trimmedMotions);
                    
                } catch (error) {
                    console.error('âŒ Failed to proceed to blend:', error);
                    statusIndicator.textContent = `Error: ${error.message}`;
                    statusIndicator.style.background = '#f8d7da';
                    statusIndicator.style.color = '#721c24';
                    metricsCard.classList.remove('visible');
                } finally {
                    // Reset button
                    proceedBtn.disabled = false;
                    proceedBtn.textContent = 'Proceed to Blend';
                }
            });
            
            // Artifacts Generate Button Handler (in Artifacts tab)
            document.getElementById('artifacts-generate-btn').addEventListener('click', async () => {
                console.log('ðŸŽ¬ Generating artifacts from artifacts tab...');
                
                const statusIndicator = document.getElementById('artifacts-status-indicator');
                const generateBtn = document.getElementById('artifacts-generate-btn');
                const blendPreviews = document.getElementById('artifacts-blend-previews');
                const useGemini = document.getElementById('artifacts-use-gemini').checked;
                
                // Get selected motions from blend state
                const selectedMotions = [];
                for (let slot = 1; slot <= 3; slot++) {
                    if (blendState.slots[slot]) {
                        const motion = blendState.slots[slot].motion;
                        const weightSlider = document.getElementById(`weight-slider-${slot}`);
                        const weight = weightSlider ? parseFloat(weightSlider.value) / 100 : (1 / Object.values(blendState.slots).filter(s => s !== null).length);
                        
                        selectedMotions.push({
                            slot,
                            motion,
                            weight,
                            startFrame: motion.trimStart || 0,
                            endFrame: motion.trimEnd || (motion.frames - 1),
                            trimmedFrameCount: (motion.trimEnd || (motion.frames - 1)) - (motion.trimStart || 0) + 1
                        });
                    }
                }
                
                if (selectedMotions.length < 2) {
                    alert('Please select at least 2 motions in the Animations tab');
                    return;
                }
                
                // Show loading state
                generateBtn.classList.add('generating');
                generateBtn.disabled = true;
                blendPreviews.innerHTML = '<div style="padding: 20px; text-align: center; color: #666; font-size: 12px;">Generating artifacts...</div>';
                
                statusIndicator.textContent = useGemini 
                    ? 'âœ¨ Analyzing motions with Gemini AI...' 
                    : 'Generating transition artifacts with BlendAnim...';
                statusIndicator.style.background = '#fff3cd';
                statusIndicator.style.color = '#856404';
                
                try {
                    // Prepare API request
                    const motion_paths = selectedMotions.map(m => m.motion.path);
                    const weights = selectedMotions.map(m => m.weight);
                    const crosshatch_offsets = selectedMotions.map(m => blendState.crosshatchOffsets[m.slot] || 0);
                    const actual_frame_counts = selectedMotions.map(m => m.trimmedFrameCount);
                    
                    const apiEndpoint = useGemini ? '/api/artifacts/generate-intelligent' : '/api/artifacts/generate';
                    
                    console.log(`ðŸ“¤ Sending to ${useGemini ? 'Gemini-powered' : 'standard'} BlendAnim API:`, { 
                        motion_paths, 
                        weights, 
                        crosshatch_offsets,
                        actual_frame_counts 
                    });
                    
                    const requestBody = {
                        motion_paths,
                        weights,
                        crosshatch_offsets,
                        actual_frame_counts,
                        blend_mode: 'smoothstep',
                        transition_frames: 30
                    };
                    
                    if (useGemini) {
                        requestBody.use_gemini_analysis = true;
                        requestBody.frame_sample_rate = 5;
                    }
                    
                    const response = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Artifact generation failed');
                    }
                    
                    const result = await response.json();
                    console.log('âœ… Artifacts generated:', result);
                    
                    // Store artifact data
                    blendState.currentArtifacts = result;
                    
                    // Update status
                    const totalFrames = result.artifacts.length;
                    statusIndicator.textContent = `âœ“ ${totalFrames} frames generated`;
                    statusIndicator.style.background = '#d4edda';
                    statusIndicator.style.color = '#155724';
                    
                    // Generate blend preview thumbnails
                    await generateArtifactsBlendThumbnails(result, blendPreviews);
                    
                    // Load artifacts in 3D viewport
                    await loadArtifactsInViewer(result);
                    
                    console.log('âœ… Artifacts loaded in viewport');
                    
                } catch (error) {
                    console.error('âŒ Artifact generation failed:', error);
                    
                    statusIndicator.textContent = `Error: ${error.message}`;
                    statusIndicator.style.background = '#f8d7da';
                    statusIndicator.style.color = '#721c24';
                    
                    blendPreviews.innerHTML = `<div style="padding: 20px; text-align: center; color: #d32f2f; font-size: 12px;">
                        Failed to generate artifacts: ${error.message}
                    </div>`;
                } finally {
                    // Reset button
                    generateBtn.classList.remove('generating');
                    generateBtn.disabled = false;
                }
            });
            
            // Show floating success popup
            function showArtifactsSuccessPopup(result) {
                const popup = document.createElement('div');
                popup.className = 'artifacts-success-popup';
                popup.innerHTML = `
                    <div class="popup-content">
                        <div class="popup-icon">âœ“</div>
                        <div class="popup-title">Artifacts Generated Successfully</div>
                        <div class="popup-subtitle">${result.artifacts.length} transition frames created</div>
                        <div class="popup-metrics">
                            <div class="metric">
                                <span class="metric-label">Coverage</span>
                                <span class="metric-value">${(result.aggregate_metrics.coverage * 100).toFixed(1)}%</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Quality</span>
                                <span class="metric-value">${result.aggregate_metrics.quality_tier}</span>
                            </div>
                        </div>
                        <button class="popup-action-btn" onclick="switchToArtifactsTab()">
                            <span>View 3D Playback</span>
                            <span>â†’</span>
                        </button>
                    </div>
                `;
                
                document.body.appendChild(popup);
                
                // Auto-remove after 8 seconds
                setTimeout(() => {
                    popup.classList.add('fade-out');
                    setTimeout(() => popup.remove(), 300);
                }, 8000);
            }
            
            // Show floating error popup
            function showArtifactsErrorPopup(errorMessage) {
                const popup = document.createElement('div');
                popup.className = 'artifacts-error-popup';
                popup.innerHTML = `
                    <div class="popup-content">
                        <div class="popup-icon error">âœ—</div>
                        <div class="popup-title">Artifact Generation Failed</div>
                        <div class="popup-subtitle">${errorMessage}</div>
                        <button class="popup-action-btn retry" onclick="document.getElementById('generate-artifacts-btn').click()">
                            Try Again
                        </button>
                    </div>
                `;
                
                document.body.appendChild(popup);
                
                // Auto-remove after 6 seconds
                setTimeout(() => {
                    popup.classList.add('fade-out');
                    setTimeout(() => popup.remove(), 300);
                }, 6000);
            }
            
            // Function to switch to artifacts tab
            window.switchToArtifactsTab = function() {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                document.querySelector('[data-tab="artifacts"]').classList.add('active');
                document.getElementById('artifacts-tab').classList.add('active');
                
                // Load artifacts in the viewer
                if (blendState.currentArtifacts) {
                    loadArtifactsInViewer(blendState.currentArtifacts);
                }
            }
            
            // Load artifacts in the new viewer layout
            async function loadArtifactsInViewer(artifactsData) {
                console.log('ðŸ“¦ Loading artifacts in viewer:', artifactsData);
                
                // Show loading state in thumbnail
                const thumbnail = document.getElementById('artifacts-thumbnail');
                if (thumbnail) {
                    thumbnail.innerHTML = `
                        <div style="text-align: center;">
                            <svg width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="#667eea" stroke-width="2">
                                <circle cx="12" cy="12" r="10" opacity="0.25"/>
                                <path d="M12 2 A10 10 0 0 1 22 12" stroke-linecap="round">
                                    <animateTransform attributeName="transform" type="rotate" from="0 12 12" to="360 12 12" dur="1s" repeatCount="indefinite"/>
                                </path>
                            </svg>
                            <div style="margin-top: 8px; font-size: 12px; color: #666;">Processing...</div>
                        </div>
                    `;
                }
                
                // Update animation card
                const frameCount = document.getElementById('artifacts-frame-count');
                const quality = document.getElementById('artifacts-quality');
                
                frameCount.textContent = artifactsData.artifacts.length;
                quality.textContent = artifactsData.aggregate_metrics.quality_tier;
                quality.style.background = getQualityColor(artifactsData.aggregate_metrics.quality_tier);
                quality.style.color = 'white';
                
                // Update Gemini insights if available
                if (artifactsData.gemini_analysis) {
                    console.log('âœ¨ Displaying Gemini insights');
                    const geminiSection = document.getElementById('gemini-insights-section');
                    const compatibility = document.getElementById('gemini-compatibility');
                    const motionTypes = document.getElementById('gemini-motion-types');
                    const predictedQuality = document.getElementById('gemini-predicted-quality');
                    const recommendation = document.getElementById('gemini-recommendation');
                    
                    geminiSection.style.display = 'block';
                    
                    // Format compatibility score
                    const compatScore = (artifactsData.gemini_analysis.compatibility_score * 100).toFixed(0);
                    compatibility.textContent = `${compatScore}%`;
                    compatibility.style.color = compatScore >= 80 ? '#4caf50' : compatScore >= 60 ? '#ff9800' : '#f44336';
                    
                    // Motion types
                    motionTypes.textContent = `${artifactsData.gemini_analysis.motion_a_type} â†’ ${artifactsData.gemini_analysis.motion_b_type}`;
                    
                    // Predicted quality
                    const predSmooth = (artifactsData.gemini_analysis.quality_prediction.predicted_smoothness * 100).toFixed(0);
                    predictedQuality.textContent = `${predSmooth}% smoothness`;
                    predictedQuality.style.color = predSmooth >= 85 ? '#4caf50' : predSmooth >= 70 ? '#ff9800' : '#f44336';
                    
                    // Recommendation (truncate if too long)
                    const rec = artifactsData.gemini_analysis.overall_recommendation;
                    recommendation.textContent = rec.length > 120 ? rec.substring(0, 117) + '...' : rec;
                } else {
                    // Hide Gemini section if not available
                    document.getElementById('gemini-insights-section').style.display = 'none';
                }
                
                // Build reference strip by copying from blend tab
                console.log('ðŸ” Step 2: Copying reference strip from blend tab');
                
                const artifactsFramePreviews = document.getElementById('artifacts-frame-previews');
                const blendFramePreviews = document.getElementById('frame-previews-blend');
                const artifactsOverlapViz = document.getElementById('artifacts-overlap-viz');
                const blendOverlapViz = document.getElementById('blend-overlap-viz');
                
                // Simple copy of thumbnails from blend tab
                if (artifactsFramePreviews && blendFramePreviews) {
                    artifactsFramePreviews.innerHTML = blendFramePreviews.innerHTML;
                    console.log('âœ… Copied thumbnails from blend tab');
                } else {
                    console.error('âŒ Missing frame preview containers');
                }
                
                // Simple copy of crosshatch overlays from blend tab
                if (artifactsOverlapViz && blendOverlapViz) {
                    artifactsOverlapViz.innerHTML = blendOverlapViz.innerHTML;
                    console.log('âœ… Copied crosshatch overlays from blend tab');
                } else {
                    console.error('âŒ Missing overlap viz containers');
                }
                
                // Load artifacts in 3D viewer first
                if (artifactsViewer) {
                    await artifactsViewer.loadArtifacts(artifactsData);
                } else {
                    console.warn('âš ï¸ Artifacts viewer not initialized yet');
                }
                
                // Wait 3 seconds then render high-quality thumbnail from 3D viewport
                setTimeout(() => {
                    console.log('ðŸ” Step 3: Rendering card thumbnail from 3D viewport');
                    console.log('  Viewer exists:', !!artifactsViewer);
                    console.log('  Renderer exists:', !!artifactsViewer?.renderer);
                    console.log('  Character exists:', !!artifactsViewer?.character);
                    console.log('  Thumbnail container exists:', !!thumbnail);
                    
                    if (artifactsViewer && artifactsViewer.renderer && artifactsViewer.character && thumbnail) {
                        // Render current frame to high-res texture
                        const canvas = document.createElement('canvas');
                        canvas.width = 400;  // High-res
                        canvas.height = 400;
                        canvas.style.width = '100%';
                        canvas.style.height = '100%';
                        canvas.style.objectFit = 'cover';
                        
                        // Take snapshot from renderer
                        const ctx = canvas.getContext('2d');
                        try {
                            // Force a render first
                            artifactsViewer.renderer.render(artifactsViewer.scene, artifactsViewer.camera);
                            
                            // Get the current renderer's canvas
                            const viewportCanvas = artifactsViewer.renderer.domElement;
                            
                            // Draw scaled version for crisp thumbnail
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'high';
                            ctx.drawImage(viewportCanvas, 0, 0, canvas.width, canvas.height);
                            
                            thumbnail.innerHTML = '';
                            thumbnail.appendChild(canvas);
                            console.log('âœ… Card thumbnail rendered from 3D viewport (high-quality)');
                        } catch (error) {
                            console.error('âŒ Failed to render thumbnail:', error);
                            // Fallback to gradient placeholder
                            const gradient = ctx.createLinearGradient(0, 0, 400, 400);
                            gradient.addColorStop(0, '#667eea');
                            gradient.addColorStop(1, '#764ba2');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(0, 0, 400, 400);
                            
                            thumbnail.innerHTML = '';
                            thumbnail.appendChild(canvas);
                        }
                    } else {
                        console.warn('âš ï¸ Artifacts viewer not ready for thumbnail');
                        console.warn('  Missing components:', {
                            viewer: !artifactsViewer,
                            renderer: !artifactsViewer?.renderer,
                            character: !artifactsViewer?.character,
                            thumbnail: !thumbnail
                        });
                        
                        // Show placeholder if missing components
                        if (thumbnail) {
                            const canvas = document.createElement('canvas');
                            canvas.width = 400;
                            canvas.height = 400;
                            canvas.style.width = '100%';
                            canvas.style.height = '100%';
                            const ctx = canvas.getContext('2d');
                            const gradient = ctx.createLinearGradient(0, 0, 400, 400);
                            gradient.addColorStop(0, '#667eea');
                            gradient.addColorStop(1, '#764ba2');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(0, 0, 400, 400);
                            
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('Loading...', 200, 200);
                            
                            thumbnail.innerHTML = '';
                            thumbnail.appendChild(canvas);
                        }
                    }
                }, 3000);
            }
            
            function getQualityColor(tier) {
                const colors = {
                    'ultra': 'linear-gradient(135deg, #4CAF50, #66BB6A)',
                    'high': 'linear-gradient(135deg, #2196F3, #42A5F5)',
                    'medium': 'linear-gradient(135deg, #FF9800, #FFB74D)',
                    'low': 'linear-gradient(135deg, #f44336, #e57373)'
                };
                return colors[tier] || colors['medium'];
            }
            
            // Render blend preview (thumbnail view)
            async function renderBlendPreview(selectedMotions, container) {
                console.log('ðŸ“Š Rendering blend preview...');
                
                container.innerHTML = '';
                const blendOutputContainer = container.parentElement;
                
                // Remove old crosshatch overlays
                if (blendOutputContainer) {
                    const oldCrosshatch = blendOutputContainer.querySelectorAll('.blend-crosshatch-overlay');
                    oldCrosshatch.forEach(el => el.remove());
                }
                
                let cumulativePixelPosition = 0;
                
                // Calculate actual frame distribution
                for (const { slot, motion, weight, frameContainer } of selectedMotions) {
                    const offset = blendState.crosshatchOffsets[slot] || 0;
                    const thumbnails = frameContainer.querySelectorAll('.frame-thumb');
                    const thumbnailsToTake = Math.round(thumbnails.length * weight);
                    
                    // Calculate start index based on offset
                    const maxStartIndex = Math.max(0, thumbnails.length - thumbnailsToTake);
                    const startIndex = Math.round(maxStartIndex * offset);
                    const endIndex = startIndex + thumbnailsToTake;
                    
                    const startPixelPosition = cumulativePixelPosition;
                    const thumbnailsBeforeCount = container.children.length;
                    let actualThumbnailsCopied = 0;
                    
                    // Copy thumbnails from the selected range
                    for (let i = startIndex; i < endIndex && i < thumbnails.length; i++) {
                        const sourceCanvas = thumbnails[i];
                        if (sourceCanvas && sourceCanvas.tagName === 'CANVAS') {
                            const newCanvas = document.createElement('canvas');
                            newCanvas.width = sourceCanvas.width;
                            newCanvas.height = sourceCanvas.height;
                            newCanvas.className = 'frame-thumb';
                            
                            const ctx = newCanvas.getContext('2d');
                            ctx.drawImage(sourceCanvas, 0, 0);
                            
                            container.appendChild(newCanvas);
                            actualThumbnailsCopied++;
                        }
                    }
                    
                    // Measure actual rendered width
                    const thumbnailsAfterCount = container.children.length;
                    let measuredWidth = 0;
                    if (thumbnailsAfterCount > thumbnailsBeforeCount) {
                        const firstNewThumb = container.children[thumbnailsBeforeCount];
                        const lastNewThumb = container.children[thumbnailsAfterCount - 1];
                        const firstRect = firstNewThumb.getBoundingClientRect();
                        const lastRect = lastNewThumb.getBoundingClientRect();
                        measuredWidth = (lastRect.left + lastRect.width) - firstRect.left;
                    }
                    
                    cumulativePixelPosition += measuredWidth;
                    
                    // Add crosshatch overlay
                    if (actualThumbnailsCopied > 0 && measuredWidth > 0) {
                        const extensionPerSide = 20;
                        const leftExtension = selectedMotions.indexOf(selectedMotions.find(m => m.slot === slot)) > 0 ? extensionPerSide : 0;
                        const rightExtension = slot < Math.max(...selectedMotions.map(m => m.slot)) ? extensionPerSide : 0;
                        
                        const crosshatchLeft = startPixelPosition - leftExtension;
                        const crosshatchWidth = measuredWidth + leftExtension + rightExtension;
                        
                        const borderColor = slot === 1 ? '#4CAF50' : slot === 2 ? '#2196F3' : '#FF9800';
                        const bgColor = slot === 1 ? 'rgba(76, 175, 80, 0.3)' : slot === 2 ? 'rgba(33, 150, 243, 0.3)' : 'rgba(255, 152, 0, 0.3)';
                        
                        const crosshatchOverlay = document.createElement('div');
                        crosshatchOverlay.className = `blend-crosshatch-overlay ${slot === 1 ? 'green-shadow' : slot === 2 ? 'blue-shadow' : 'orange-shadow'}`;
                        crosshatchOverlay.style.cssText = `
                            position: absolute;
                            bottom: 25px;
                            left: ${crosshatchLeft}px;
                            width: ${crosshatchWidth}px;
                            height: 35px;
                            background-color: ${bgColor};
                            border: 2px solid ${borderColor};
                            border-radius: 8px;
                            box-sizing: border-box;
                            pointer-events: none;
                            z-index: 10;
                        `;
                        container.appendChild(crosshatchOverlay);
                    }
                }
            }
            
            // Add click handlers to motion strips to copy to blend output
            function setupStripClickHandlers() {
                for (let slot = 1; slot <= 3; slot++) {
                    const stripTimeline = document.querySelector(`#animation-strip-${slot} .strip-timeline`);
                    const framePreviewsContainer = document.getElementById(`frame-previews-${slot}`);
                    
                    if (stripTimeline && framePreviewsContainer) {
                        stripTimeline.style.cursor = 'pointer';
                        
                        stripTimeline.addEventListener('click', () => {
                            console.log(`ðŸ“‹ Copying strip ${slot} to blend output...`);
                            
                            // Get the source thumbnails
                            const sourceThumbnails = framePreviewsContainer.querySelectorAll('.frame-thumb');
                            
                            if (sourceThumbnails.length === 0) {
                                console.warn('No thumbnails to copy');
                                return;
                            }
                            
                            // Get blend output container
                            const blendContainer = document.getElementById('frame-previews-blend');
                            const blendShadow = document.querySelector('.blend-output-shadow');
                            
                            // Clear blend output
                            blendContainer.innerHTML = '';
                            
                            // Copy thumbnails
                            sourceThumbnails.forEach(thumb => {
                                const clone = thumb.cloneNode(true);
                                blendContainer.appendChild(clone);
                            });
                            
                            // Update blend output crosshatch color to match source
                            const colorClass = slot === 1 ? 'green-shadow' : slot === 2 ? 'blue-shadow' : 'orange-shadow';
                            if (blendShadow) {
                                blendShadow.className = 'color-shadow ' + colorClass;
                            }
                            
                            console.log(`âœ… Copied ${sourceThumbnails.length} thumbnails to blend output`);
                            
                            // Update status
                            const statusIndicator = document.querySelector('.blend-status-indicator');
                            const motionName = blendState.slots[slot]?.motion?.name || `Motion ${slot}`;
                            statusIndicator.textContent = `Preview: ${motionName}`;
                            statusIndicator.style.background = '#e3f2fd';
                            statusIndicator.style.color = '#0d47a1';
                        });
                    }
                }
            }
            
            // Initialize strip click handlers after strips are populated
            setupStripClickHandlers();
            
            // Initialize slot drag and drop
            setupSlotDragAndDrop();
            
            // Initialize weight sliders
            setupWeightSliders();
            
            // Initialize crosshatch dragging
            setupCrosshatchDragging();
            
            // Calculate optimal frame count based on animation length
            function calculateFrameCount(totalFrames) {
                if (totalFrames <= 200) return 14;
                if (totalFrames <= 300) return 16;
                if (totalFrames <= 400) return 18;
                return 20; // For very long animations like 505 frames
            }
            
            // Generate sequence thumbnails for blend strip
            function generateBlendStripThumbnails(motion, slot) {
                console.log(`ðŸŽžï¸ Generating blend strip thumbnails for: ${motion.name} in slot ${slot}`);
                
                const container = document.getElementById(`frame-previews-${slot}`);
                container.innerHTML = '<div style="padding: 20px; color: #666; font-size: 12px;">Loading frames...</div>';
                
                const thumbWidth = 80;
                const thumbHeight = 80;
                
                // Load character model
                const loader = new THREE.FBXLoader();
                loader.load(
                    '/static/models/Ch03_nonPBR.fbx',
                    (character) => {
                        character.scale.set(0.01, 0.01, 0.01);
                        
                        // Load animation
                        loader.load(
                            motion.path,
                            (animFbx) => {
                                if (!animFbx.animations || animFbx.animations.length === 0) {
                                    container.innerHTML = '<div style="padding: 20px; color: #999;">No animation data</div>';
                                    return;
                                }
                                
                                const animation = animFbx.animations[0];
                                const duration = animation.duration;
                                const fps = 30; // Mixamo standard
                                const totalFrames = Math.floor(duration * fps);
                                
                                // Store ACTUAL frame count from animation
                                blendState.frameCounts[slot] = totalFrames;
                                console.log(`ðŸŽžï¸ Animation has ${totalFrames} actual frames at ${fps} fps (${duration.toFixed(2)}s)`);
                                
                                const numFrames = calculateFrameCount(totalFrames);
                                
                                // Store thumbnail count for crosshatch calculations
                                blendState.thumbnailCounts[slot] = numFrames;
                                
                                console.log(`ðŸ“Š Generating ${numFrames} thumbnail frames for display`);
                                
                                const mixer = new THREE.AnimationMixer(character);
                                const action = mixer.clipAction(animation);
                                action.enabled = true;
                                action.play();
                                
                                // Create offscreen scene for rendering
                                const thumbScene = new THREE.Scene();
                                thumbScene.background = new THREE.Color(0xffffff);
                                thumbScene.add(character);
                                
                                // Add continuous checkerboard floor (4x4 for proper scale)
                                const floorSize = 4;
                                const checkerSize = 0.5;
                                const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
                                
                                const stripCheckerCanvas = document.createElement('canvas');
                                stripCheckerCanvas.width = 64;
                                stripCheckerCanvas.height = 64;
                                const stripCtx = stripCheckerCanvas.getContext('2d');
                                const stripSquareSize = stripCheckerCanvas.width / (floorSize / checkerSize);
                                
                                for (let i = 0; i < floorSize / checkerSize; i++) {
                                    for (let j = 0; j < floorSize / checkerSize; j++) {
                                        stripCtx.fillStyle = (i + j) % 2 === 0 ? '#e0e0e0' : '#999999';
                                        stripCtx.fillRect(i * stripSquareSize, j * stripSquareSize, stripSquareSize, stripSquareSize);
                                    }
                                }
                                
                                const stripCheckerTexture = new THREE.CanvasTexture(stripCheckerCanvas);
                                stripCheckerTexture.wrapS = THREE.RepeatWrapping;
                                stripCheckerTexture.wrapT = THREE.RepeatWrapping;
                                stripCheckerTexture.repeat.set(1, 1);
                                
                                const stripFloorMaterial = new THREE.MeshStandardMaterial({ 
                                    map: stripCheckerTexture,
                                    roughness: 0.8,
                                    metalness: 0.2
                                });
                                const stripFloor = new THREE.Mesh(floorGeometry, stripFloorMaterial);
                                stripFloor.rotation.x = -Math.PI / 2;
                                stripFloor.receiveShadow = true;
                                thumbScene.add(stripFloor);
                                
                                // Lights
                                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                                directionalLight.position.set(5, 10, 7.5);
                                directionalLight.castShadow = true;
                                thumbScene.add(ambientLight);
                                thumbScene.add(directionalLight);
                                
                                // Ensure character materials are ready
                                character.traverse((child) => {
                                    if (child.isMesh) {
                                        child.castShadow = true;
                                        child.receiveShadow = true;
                                        if (child.material) {
                                            child.material.needsUpdate = true;
                                        }
                                    }
                                });
                                
                                // Camera - Perspective with single vanishing point, lowered for 3D view
                                const box = new THREE.Box3().setFromObject(character);
                                const center = box.getCenter(new THREE.Vector3());
                                const size = box.getSize(new THREE.Vector3());
                                
                                // Perspective camera with single vanishing point at center
                                const thumbCamera = new THREE.PerspectiveCamera(35, 1, 0.1, 2000);
                                
                                // Lower camera for 3D perspective view
                                const cameraHeight = center.y + size.y * 0.2; // Lower height for more 3D feel
                                const cameraDistance = Math.max(size.x, size.y, size.z) * 2.5;
                                
                                // Fixed camera position for continuous floor with single vanishing point
                                thumbCamera.position.set(0, cameraHeight, cameraDistance);
                                thumbCamera.lookAt(0, center.y * 0.5, 0); // Look slightly below center for floor visibility
                                
                                // Create ONE reusable renderer for all frames
                                const offscreenCanvas = document.createElement('canvas');
                                offscreenCanvas.width = thumbWidth;
                                offscreenCanvas.height = thumbHeight;
                                const sharedRenderer = new THREE.WebGLRenderer({ 
                                    canvas: offscreenCanvas, 
                                    antialias: true,
                                    preserveDrawingBuffer: true 
                                });
                                sharedRenderer.setSize(thumbWidth, thumbHeight);
                                
                                // Clear container
                                container.innerHTML = '';
                                
                                // Wait 3 seconds for materials to load, then generate frames
                                setTimeout(() => {
                                    // Generate frames using the shared renderer
                                    for (let i = 0; i < numFrames; i++) {
                                        const progress = i / (numFrames - 1);
                                        const time = duration * progress;
                                        
                                        action.time = time;
                                        mixer.update(0.001);
                                        
                                        // Render to shared canvas
                                        sharedRenderer.render(thumbScene, thumbCamera);
                                        
                                        // Copy rendered image to a new canvas for display
                                        const displayCanvas = document.createElement('canvas');
                                        displayCanvas.width = thumbWidth;
                                        displayCanvas.height = thumbHeight;
                                        displayCanvas.className = 'frame-thumb';
                                        const ctx = displayCanvas.getContext('2d');
                                        ctx.drawImage(offscreenCanvas, 0, 0);
                                        
                                        container.appendChild(displayCanvas);
                                    }
                                    
                                    // Dispose the single renderer after all frames are generated
                                    sharedRenderer.dispose();
                                    
                                    console.log(`âœ… Generated ${numFrames} frame thumbnails for ${motion.name}`);
                                    
                                    // Initialize crosshatch position and width after thumbnails load
                                    setTimeout(() => {
                                        const crosshatch = container.nextElementSibling;
                                        if (crosshatch && crosshatch.classList.contains('color-shadow')) {
                                            const containerWidth = container.offsetWidth;
                                            crosshatch.style.width = `${containerWidth}px`;
                                            crosshatch.style.left = '0px';
                                            console.log(`ðŸŽ¯ Initialized crosshatch for slot ${slot}: width=${containerWidth}px, left=0px`);
                                        }
                                        
                                        // Update crosshatch based on current weights
                                        updateCrosshatchOverlap();
                                    }, 100);
                                }, 3000);
                            },
                            undefined,
                            (error) => {
                                console.error(`Failed to load animation:`, error);
                                container.innerHTML = '<div style="padding: 20px; color: #f44336;">Failed to load</div>';
                            }
                        );
                    },
                    undefined,
                    (error) => {
                        console.error(`Failed to load character:`, error);
                        container.innerHTML = '<div style="padding: 20px; color: #f44336;">Failed to load character</div>';
                    }
                );
            }
            
            /**
             * Calculate blend metrics from trimmed motions
             */
            function calculateBlendMetrics(trimmedMotions) {
                // Calculate total frames (max of all sequences)
                const totalFrames = Math.max(...trimmedMotions.map(m => m.trimmedFrameCount));
                
                // Calculate total duration at 30fps
                const duration = totalFrames / 30;
                
                // Calculate compatibility score based on frame count similarity
                const frameCounts = trimmedMotions.map(m => m.trimmedFrameCount);
                const avgFrames = frameCounts.reduce((a, b) => a + b, 0) / frameCounts.length;
                const variance = frameCounts.reduce((sum, count) => sum + Math.pow(count - avgFrames, 2), 0) / frameCounts.length;
                const stdDev = Math.sqrt(variance);
                
                // Compatibility: 100% if all same length, decreases with variance
                const maxStdDev = avgFrames * 0.5; // 50% variance = 0% compatibility
                const compatibility = Math.max(0, Math.min(100, 100 - (stdDev / maxStdDev * 100)));
                
                // Determine quality tier based on compatibility and motion count
                let qualityTier = 'Standard';
                if (compatibility >= 80 && trimmedMotions.length >= 3) {
                    qualityTier = 'Premium';
                } else if (compatibility >= 60) {
                    qualityTier = 'Good';
                } else if (compatibility < 40) {
                    qualityTier = 'Experimental';
                }
                
                return {
                    totalFrames,
                    sequenceCount: trimmedMotions.length,
                    duration,
                    compatibility: Math.round(compatibility),
                    qualityTier,
                    frameCounts,
                    avgFrames: Math.round(avgFrames)
                };
            }
            
            // Generate trimmed blend strip thumbnails
            function generateTrimmedBlendStrip(trimmedMotion) {
                const { slot, motion, startFrame, endFrame, trimmedFrameCount } = trimmedMotion;
                console.log(`âœ‚ï¸ Generating trimmed blend strip for: ${motion.name} (frames ${startFrame}-${endFrame})`);
                
                const container = document.getElementById(`frame-previews-${slot}`);
                container.innerHTML = '<div style="padding: 20px; color: #666; font-size: 12px;">Loading trimmed frames...</div>';
                
                const thumbWidth = 80;
                const thumbHeight = 80;
                
                // Load character model
                const loader = new THREE.FBXLoader();
                loader.load(
                    '/static/models/Ch03_nonPBR.fbx',
                    (character) => {
                        character.scale.set(0.01, 0.01, 0.01);
                        
                        // Load animation
                        loader.load(
                            motion.path,
                            (animFbx) => {
                                if (!animFbx.animations || animFbx.animations.length === 0) {
                                    container.innerHTML = '<div style="padding: 20px; color: #999;">No animation data</div>';
                                    return;
                                }
                                
                                const animation = animFbx.animations[0];
                                const duration = animation.duration;
                                const fps = 30; // Mixamo standard
                                const totalFrames = Math.floor(duration * fps);
                                
                                // Calculate frame range in time
                                const startTime = (startFrame / totalFrames) * duration;
                                const endTime = (endFrame / totalFrames) * duration;
                                const trimmedDuration = endTime - startTime;
                                
                                // Store trimmed frame count
                                blendState.frameCounts[slot] = trimmedFrameCount;
                                
                                const numFrames = calculateFrameCount(trimmedFrameCount);
                                blendState.thumbnailCounts[slot] = numFrames;
                                
                                console.log(`ðŸ“Š Generating ${numFrames} thumbnails for trimmed range: ${startFrame}-${endFrame} (${trimmedFrameCount} frames, ${trimmedDuration.toFixed(2)}s)`);
                                
                                const mixer = new THREE.AnimationMixer(character);
                                const action = mixer.clipAction(animation);
                                action.enabled = true;
                                action.play();
                                
                                // Create offscreen scene
                                const thumbScene = new THREE.Scene();
                                thumbScene.background = new THREE.Color(0xffffff);
                                thumbScene.add(character);
                                
                                // Add floor (same as original)
                                const floorSize = 4;
                                const checkerSize = 0.5;
                                const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
                                const stripCheckerCanvas = document.createElement('canvas');
                                stripCheckerCanvas.width = 64;
                                stripCheckerCanvas.height = 64;
                                const stripCtx = stripCheckerCanvas.getContext('2d');
                                const stripSquareSize = stripCheckerCanvas.width / (floorSize / checkerSize);
                                
                                for (let i = 0; i < floorSize / checkerSize; i++) {
                                    for (let j = 0; j < floorSize / checkerSize; j++) {
                                        stripCtx.fillStyle = (i + j) % 2 === 0 ? '#e0e0e0' : '#999999';
                                        stripCtx.fillRect(i * stripSquareSize, j * stripSquareSize, stripSquareSize, stripSquareSize);
                                    }
                                }
                                
                                const stripCheckerTexture = new THREE.CanvasTexture(stripCheckerCanvas);
                                stripCheckerTexture.wrapS = THREE.RepeatWrapping;
                                stripCheckerTexture.wrapT = THREE.RepeatWrapping;
                                stripCheckerTexture.repeat.set(1, 1);
                                
                                const stripFloorMaterial = new THREE.MeshStandardMaterial({ 
                                    map: stripCheckerTexture,
                                    roughness: 0.8,
                                    metalness: 0.2
                                });
                                const stripFloor = new THREE.Mesh(floorGeometry, stripFloorMaterial);
                                stripFloor.rotation.x = -Math.PI / 2;
                                stripFloor.receiveShadow = true;
                                thumbScene.add(stripFloor);
                                
                                // Lights
                                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                                directionalLight.position.set(5, 10, 7.5);
                                directionalLight.castShadow = true;
                                thumbScene.add(ambientLight);
                                thumbScene.add(directionalLight);
                                
                                // Camera setup
                                const box = new THREE.Box3().setFromObject(character);
                                const center = box.getCenter(new THREE.Vector3());
                                const size = box.getSize(new THREE.Vector3());
                                const thumbCamera = new THREE.PerspectiveCamera(35, 1, 0.1, 2000);
                                const cameraHeight = center.y + size.y * 0.2;
                                const cameraDistance = Math.max(size.x, size.y, size.z) * 2.5;
                                thumbCamera.position.set(0, cameraHeight, cameraDistance);
                                thumbCamera.lookAt(0, center.y * 0.5, 0);
                                
                                // Renderer
                                const offscreenCanvas = document.createElement('canvas');
                                offscreenCanvas.width = thumbWidth;
                                offscreenCanvas.height = thumbHeight;
                                const sharedRenderer = new THREE.WebGLRenderer({ 
                                    canvas: offscreenCanvas, 
                                    antialias: true,
                                    preserveDrawingBuffer: true 
                                });
                                sharedRenderer.setSize(thumbWidth, thumbHeight);
                                
                                // Clear container
                                container.innerHTML = '';
                                
                                // Wait for materials, then generate trimmed frames
                                setTimeout(() => {
                                    for (let i = 0; i < numFrames; i++) {
                                        const progress = i / (numFrames - 1);
                                        const time = startTime + (trimmedDuration * progress);
                                        
                                        action.time = time;
                                        mixer.update(0.001);
                                        
                                        // Render frame
                                        sharedRenderer.render(thumbScene, thumbCamera);
                                        
                                        // Copy to display canvas
                                        const displayCanvas = document.createElement('canvas');
                                        displayCanvas.width = thumbWidth;
                                        displayCanvas.height = thumbHeight;
                                        displayCanvas.className = 'frame-thumb';
                                        const ctx = displayCanvas.getContext('2d');
                                        ctx.drawImage(offscreenCanvas, 0, 0);
                                        
                                        container.appendChild(displayCanvas);
                                    }
                                    
                                    sharedRenderer.dispose();
                                    console.log(`âœ… Generated ${numFrames} trimmed thumbnails for ${motion.name}`);
                                    
                                    // Initialize crosshatch
                                    setTimeout(() => {
                                        const crosshatch = container.nextElementSibling;
                                        if (crosshatch && crosshatch.classList.contains('color-shadow')) {
                                            const containerWidth = container.offsetWidth;
                                            crosshatch.style.width = `${containerWidth}px`;
                                            crosshatch.style.left = '0px';
                                        }
                                        updateCrosshatchOverlap();
                                    }, 100);
                                }, 3000);
                            },
                            undefined,
                            (error) => {
                                console.error(`Failed to load animation:`, error);
                                container.innerHTML = '<div style="padding: 20px; color: #f44336;">Failed to load</div>';
                            }
                        );
                    },
                    undefined,
                    (error) => {
                        console.error(`Failed to load character:`, error);
                        container.innerHTML = '<div style="padding: 20px; color: #f44336;">Failed to load character</div>';
                    }
                );
            }
            
            // Show blend controls for trimmed motions (smoothstep only)
            function showBlendControlsForTrimmedMotions(trimmedMotions) {
                console.log('ðŸŽ›ï¸ Showing blend controls for trimmed motions...');
                
                // For now, just show a simple smoothstep control
                // In the future, this could be expanded
                const statusIndicator = document.querySelector('.blend-status-indicator');
                statusIndicator.textContent = `Ready to generate artifacts with ${trimmedMotions.length} trimmed motions`;
                statusIndicator.style.background = '#d4edda';
                statusIndicator.style.color = '#155724';
                
                // Enable the generate artifacts button
                const generateBtn = document.getElementById('generate-artifacts-btn');
                if (generateBtn) {
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'Generate Artifacts';
                }
            }
            
            // Generate artifacts blend thumbnails in artifacts tab
            async function generateArtifactsBlendThumbnails(result, container) {
                console.log('ðŸ–¼ï¸ Generating artifacts blend thumbnails...');
                
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #666; font-size: 12px;">Rendering thumbnails...</div>';
                
                const thumbWidth = 80;
                const thumbHeight = 80;
                const numFrames = Math.min(result.artifacts.length, 50); // Limit thumbnails for performance
                const frameStep = Math.max(1, Math.floor(result.artifacts.length / numFrames));
                
                // Create offscreen scene for thumbnail rendering
                const thumbScene = new THREE.Scene();
                thumbScene.background = new THREE.Color(0xffffff);
                
                const thumbCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 2000);
                thumbCamera.position.set(0, 1.6, 3);
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7.5);
                thumbScene.add(ambientLight);
                thumbScene.add(directionalLight);
                
                // Load character
                const loader = new THREE.FBXLoader();
                const character = await new Promise((resolve, reject) => {
                    loader.load('/static/models/Ch03_nonPBR.fbx', resolve, undefined, reject);
                });
                
                character.scale.set(0.01, 0.01, 0.01);
                thumbScene.add(character);
                
                // Create renderer
                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = thumbWidth;
                offscreenCanvas.height = thumbHeight;
                const renderer = new THREE.WebGLRenderer({ 
                    canvas: offscreenCanvas, 
                    antialias: true,
                    preserveDrawingBuffer: true 
                });
                renderer.setSize(thumbWidth, thumbHeight);
                
                // Clear container
                container.innerHTML = '';
                
                // Generate thumbnails
                for (let i = 0; i < numFrames; i++) {
                    const frameIndex = i * frameStep;
                    const frameData = result.artifacts[frameIndex];
                    
                    if (frameData && frameData.positions) {
                        // Apply pose from artifact data
                        applyPoseFromArtifact(character, frameData);
                        
                        // Render frame
                        renderer.render(thumbScene, thumbCamera);
                        
                        // Copy to display canvas
                        const displayCanvas = document.createElement('canvas');
                        displayCanvas.width = thumbWidth;
                        displayCanvas.height = thumbHeight;
                        displayCanvas.className = 'frame-thumb';
                        const ctx = displayCanvas.getContext('2d');
                        ctx.drawImage(offscreenCanvas, 0, 0);
                        
                        container.appendChild(displayCanvas);
                    }
                }
                
                renderer.dispose();
                console.log(`âœ… Generated ${numFrames} artifact blend thumbnails`);
            }
            
            // Apply pose from artifact data to character
            function applyPoseFromArtifact(character, frameData) {
                // Apply positions from artifact data
                character.traverse((bone) => {
                    if (bone.isBone && bone.name) {
                        // Find matching bone in artifact data
                        const boneIdx = frameData.bone_names ? frameData.bone_names.indexOf(bone.name) : -1;
                        if (boneIdx >= 0 && frameData.positions[boneIdx]) {
                            const pos = frameData.positions[boneIdx];
                            bone.position.set(pos[0], pos[1], pos[2]);
                        }
                    }
                });
                
                character.updateMatrixWorld(true);
            }
            
            // Clear blend strip thumbnails
            function clearBlendStripThumbnails(slot) {
                const container = document.getElementById(`frame-previews-${slot}`);
                container.innerHTML = '';
            }
            
            // Generate thumbnail preview for motion
            function generateThumbnail(motion) {
                const thumbnailDiv = document.getElementById(`thumb-${motion.id}`);
                if (!thumbnailDiv) {
                    console.warn(`âš ï¸ Thumbnail div not found for ${motion.id}`);
                    return;
                }
                
                console.log(`ðŸ–¼ï¸ Generating thumbnail for: ${motion.name}`);
                
                // Create offscreen scene for thumbnail
                const thumbScene = new THREE.Scene();
                thumbScene.background = new THREE.Color(0xffffff);
                
                const thumbCamera = new THREE.PerspectiveCamera(45, 16/9, 0.1, 2000);
                thumbCamera.position.set(0, 1.6, 3);
                
                const thumbCanvas = document.createElement('canvas');
                thumbCanvas.width = 320;
                thumbCanvas.height = 180;
                
                const thumbRenderer = new THREE.WebGLRenderer({ 
                    canvas: thumbCanvas,
                    antialias: true 
                });
                thumbRenderer.setSize(320, 180);
                thumbRenderer.shadowMap.enabled = true;
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                thumbScene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7.5);
                directionalLight.castShadow = true;
                thumbScene.add(directionalLight);
                
                const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
                rimLight.position.set(-5, 5, -5);
                thumbScene.add(rimLight);
                
                // Load character model first
                const loader = new THREE.FBXLoader();
                const characterPath = '/static/models/Ch03_nonPBR.fbx';
                
                loader.load(
                    characterPath,
                    (character) => {
                        character.scale.set(0.01, 0.01, 0.01);
                        character.position.set(0, 0, 0);
                        
                        // Enable shadows and ensure materials are ready
                        character.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                if (child.material) {
                                    child.material.needsUpdate = true;
                                }
                            }
                        });
                        
                        thumbScene.add(character);
                        
                        // Now load and apply animation
                        loader.load(
                            motion.path,
                            (animFbx) => {
                                console.log(`âœ… Animation loaded for thumbnail: ${motion.name}`);
                                
                                if (animFbx.animations && animFbx.animations.length > 0) {
                                    const mixer = new THREE.AnimationMixer(character);
                                    const action = mixer.clipAction(animFbx.animations[0]);
                                    const duration = animFbx.animations[0].duration;
                                    
                                    // Enable and play the action
                                    action.enabled = true;
                                    action.play();
                                    
                                    // Set to characteristic frame (40% through)
                                    action.time = duration * 0.4;
                                    
                                    // Update mixer to apply the pose
                                    mixer.update(0.001);
                                    
                                    // Update card with actual frame count
                                    const fps = 30; // Mixamo standard
                                    const actualFrames = Math.floor(duration * fps);
                                    const cardElement = thumbnailDiv.closest('.motion-card');
                                    if (cardElement) {
                                        const detailsDiv = cardElement.querySelector('.motion-details');
                                        if (detailsDiv) {
                                            detailsDiv.textContent = `${actualFrames} frames â€¢ ${fps} fps`;
                                        }
                                    }
                                    
                                    console.log(`ðŸŽžï¸ Thumbnail frame set to ${(duration * 0.4).toFixed(2)}s of ${duration.toFixed(2)}s (${actualFrames} total frames)`);
                                }
                                
                                // Center camera on character
                                const box = new THREE.Box3().setFromObject(character);
                                const center = box.getCenter(new THREE.Vector3());
                                const size = box.getSize(new THREE.Vector3());
                                const maxDim = Math.max(size.x, size.y, size.z);
                                const fov = thumbCamera.fov * (Math.PI / 180);
                                const distance = Math.abs(maxDim / Math.sin(fov / 2));
                                
                                thumbCamera.position.set(
                                    center.x,
                                    center.y + distance * 0.3,
                                    center.z + distance * 0.8
                                );
                                thumbCamera.lookAt(center);
                                
                                // Wait 3 seconds for materials/textures to fully load before rendering
                                setTimeout(() => {
                                    // Render thumbnail
                                    thumbRenderer.render(thumbScene, thumbCamera);
                                    
                                    // Replace loading indicator with thumbnail
                                    thumbnailDiv.innerHTML = '';
                                    thumbCanvas.style.width = '100%';
                                    thumbCanvas.style.height = '100%';
                                    thumbCanvas.style.objectFit = 'cover';
                                    thumbnailDiv.appendChild(thumbCanvas);
                                    
                                    console.log(`âœ… Thumbnail rendered for: ${motion.name}`);
                                    
                                    // Clean up
                                    thumbRenderer.dispose();
                                }, 3000);
                            },
                            undefined,
                            (error) => {
                                console.error(`âŒ Failed to load animation for thumbnail ${motion.name}:`, error);
                                thumbnailDiv.innerHTML = `<div style="font-size: 12px; color: #999; padding: 20px; text-align: center;">Animation unavailable</div>`;
                            }
                        );
                    },
                    undefined,
                    (error) => {
                        console.error(`âŒ Failed to load character for thumbnail:`, error);
                        thumbnailDiv.innerHTML = `<div style="font-size: 12px; color: #999; padding: 20px; text-align: center;">Preview unavailable</div>`;
                    }
                );
            }
            
            // Update 3D viewport to play only trimmed frames
            function updateViewportTrimRange(motion) {
                if (window.currentMotionViewer && window.currentMotionViewer.motion === motion) {
                    // Update the animation mixer to loop only the trimmed range
                    const mixer = window.currentMotionViewer.mixer;
                    const action = window.currentMotionViewer.action;
                    
                    if (mixer && action) {
                        const duration = action.getClip().duration;
                        const fps = 30; // Mixamo standard
                        const startTime = (motion.trimStart / (motion.frames - 1)) * duration;
                        const endTime = (motion.trimEnd / (motion.frames - 1)) * duration;
                        
                        // Set loop points
                        action.setLoop(THREE.LoopRepeat);
                        action.time = startTime;
                        action.setEffectiveTimeScale(1);
                        action.setEffectiveWeight(1);
                        
                        // Create a custom clip with only the trimmed range
                        const originalClip = action.getClip();
                        const trimmedTracks = originalClip.tracks.map(track => {
                            const newTrack = track.clone();
                            // Trim keyframes to the specified range
                            const startKeyframe = Math.floor((startTime / duration) * newTrack.times.length);
                            const endKeyframe = Math.ceil((endTime / duration) * newTrack.times.length);
                            
                            newTrack.times = newTrack.times.slice(startKeyframe, endKeyframe);
                            newTrack.values = newTrack.values.slice(startKeyframe * (newTrack.values.length / newTrack.times.length), 
                                                                   endKeyframe * (newTrack.values.length / newTrack.times.length));
                            
                            // Adjust times to start from 0
                            const timeOffset = newTrack.times[0];
                            newTrack.times = newTrack.times.map(t => t - timeOffset);
                            
                            return newTrack;
                        });
                        
                        const trimmedClip = new THREE.AnimationClip(
                            `${originalClip.name}_trimmed_${motion.trimStart}_${motion.trimEnd}`,
                            endTime - startTime,
                            trimmedTracks
                        );
                        
                        // Replace the action with trimmed version
                        mixer.stopAllAction();
                        const trimmedAction = mixer.clipAction(trimmedClip, window.currentMotionViewer.character);
                        trimmedAction.play();
                        window.currentMotionViewer.action = trimmedAction;
                        
                        console.log(`ðŸŽ¬ Updated viewport to play trimmed range: frames ${motion.trimStart}-${motion.trimEnd}`);
                    }
                }
            }
            
            // Update trimmed frames display
            function updateTrimmedFrames(startFrame, endFrame, trimmedFramesElement) {
                const trimmedCount = endFrame - startFrame + 1;
                trimmedFramesElement.textContent = trimmedCount;
            }
            
            // Generate thumbnail for trimmed motion range
            function generateTrimmedThumbnail(motion, startFrame, endFrame) {
                const thumbnailDiv = document.getElementById(`thumb-${motion.id}`);
                if (!thumbnailDiv) {
                    console.warn(`âš ï¸ Thumbnail div not found for ${motion.id}`);
                    return;
                }
                
                console.log(`âœ‚ï¸ Generating trimmed thumbnail for: ${motion.name} (frames ${startFrame}-${endFrame})`);
                
                // For now, just add a visual indicator that trimming is active
                // In a full implementation, this would render the animation at the trimmed range
                const trimmedIndicator = document.createElement('div');
                trimmedIndicator.style.position = 'absolute';
                trimmedIndicator.style.top = '2px';
                trimmedIndicator.style.right = '2px';
                trimmedIndicator.style.background = '#FF6700';
                trimmedIndicator.style.color = 'white';
                trimmedIndicator.style.fontSize = '10px';
                trimmedIndicator.style.padding = '1px 4px';
                trimmedIndicator.style.borderRadius = '2px';
                trimmedIndicator.textContent = 'TRIM';
                
                // Remove existing indicator if present
                const existingIndicator = thumbnailDiv.querySelector('.trim-indicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                }
                
                trimmedIndicator.className = 'trim-indicator';
                thumbnailDiv.style.position = 'relative';
                thumbnailDiv.appendChild(trimmedIndicator);
                
                console.log(`âœ… Trimmed thumbnail indicator added for: ${motion.name}`);
            }
            
            // Search functionality
            searchInput.addEventListener('input', (e) => {
                renderMotionCards(e.target.value);
            });
            
            // Load and play motion
            function loadMotion(motion, cardElement) {
                console.log('ðŸŽ¬ Loading motion:', motion.name, 'from:', motion.path);
                
                // Mark card as active
                document.querySelectorAll('.motion-card').forEach(c => c.classList.remove('active'));
                cardElement.classList.add('active');
                
                // Initialize Three.js scene if not exists
                if (!currentScene) {
                    console.log('ðŸ“ Initializing scene for first time');
                    initAnimationScene();
                }
                
                // Clear previous character
                if (currentScene.children.length > 3) { // Keep lights and grid
                    const toRemove = [];
                    currentScene.children.forEach(child => {
                        if (child.type === 'Group' || child.type === 'Object3D') {
                            toRemove.push(child);
                        }
                    });
                    toRemove.forEach(obj => currentScene.remove(obj));
                    console.log('ðŸ—‘ï¸ Cleared previous character');
                }
                
                // Load character model first, then apply animation
                const loader = new THREE.FBXLoader();
                const characterPath = '/static/models/Ch03_nonPBR.fbx';
                
                console.log('ðŸ“¥ Loading character model:', characterPath);
                
                loader.load(
                    characterPath,
                    (character) => {
                        console.log('âœ… Character loaded');
                        
                        // Scale and position character
                        character.scale.set(0.01, 0.01, 0.01);
                        character.position.set(0, 0, 0);
                        
                        // Enable meshes
                        let meshCount = 0;
                        character.traverse((child) => {
                            if (child.isMesh) {
                                child.visible = true;
                                child.castShadow = true;
                                child.receiveShadow = true;
                                meshCount++;
                            }
                        });
                        
                        console.log('   Character mesh count:', meshCount);
                        
                        // Add character to scene
                        currentScene.add(character);
                        
                        // Center camera on character - Match Characters tab method
                        const box = new THREE.Box3().setFromObject(character);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        
                        // Update controls target
                        currentControls.target.copy(center);
                        
                        // Position camera to see full character - Match Characters tab
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const fov = currentCamera.fov * (Math.PI / 180);
                        let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                        cameraZ *= 1.5; // Add some padding
                        
                        currentCamera.position.set(
                            center.x + cameraZ * 0.5, 
                            center.y + size.y * 0.3, 
                            center.z + cameraZ
                        );
                        currentCamera.lookAt(center);
                        currentControls.update();
                        
                        console.log('   Camera positioned on character');
                        
                        // Now load the animation and apply it to the character
                        console.log('ðŸ“¥ Loading animation:', motion.path);
                        
                        loader.load(
                            motion.path,
                            (animFbx) => {
                                console.log('âœ… Animation loaded:', motion.name);
                                console.log('   Animations found:', animFbx.animations.length);
                                
                                // Setup animation mixer on the character (not the animation FBX)
                                if (currentMixer) currentMixer.stopAllAction();
                                currentMixer = new THREE.AnimationMixer(character);
                                
                                if (animFbx.animations && animFbx.animations.length > 0) {
                                    currentAction = currentMixer.clipAction(animFbx.animations[0]);
                                    animationDuration = animFbx.animations[0].duration;
                                    currentAction.play();
                                    isPlaying = true;
                                    playPauseBtn.textContent = 'â¸';
                                    
                                    console.log('   Animation duration:', animationDuration, 'seconds');
                                    
                                    // Calculate actual frame count from duration
                                    const actualFrames = Math.floor(animationDuration * 30); // 30 fps standard
                                    
                                    // Update motion object with actual frame count
                                    motion.frames = actualFrames;
                                    
                                    // Update trim sliders with actual frame count
                                    const trimStart = document.getElementById(`trim-start-${motion.id}`);
                                    const trimEnd = document.getElementById(`trim-end-${motion.id}`);
                                    const trimRange = document.getElementById(`trim-range-${motion.id}`);
                                    const trimFrameCount = document.querySelector(`#motion-details-${motion.id}`).closest('.motion-card').querySelector('.trim-frame-count');
                                    const motionDetails = document.getElementById(`motion-details-${motion.id}`);
                                    
                                    if (trimStart && trimEnd) {
                                        trimStart.max = actualFrames - 1;
                                        trimEnd.max = actualFrames - 1;
                                        trimEnd.value = actualFrames - 1;
                                        motion.trimEnd = actualFrames - 1;
                                        
                                        if (trimRange) {
                                            trimRange.textContent = `0 - ${actualFrames - 1}`;
                                        }
                                        if (trimFrameCount) {
                                            trimFrameCount.textContent = `(${actualFrames} frames)`;
                                        }
                                        console.log(`âœ… Updated trim sliders to ${actualFrames} frames (from actual animation)`);
                                    }
                                    
                                    // Update motion details display
                                    if (motionDetails) {
                                        motionDetails.textContent = `${actualFrames} frames â€¢ 30 fps`;
                                    }
                                    
                                    // Store current motion for viewport trim updates
                                    window.currentMotionViewer = {
                                        motion: motion,
                                        character: character,
                                        mixer: currentMixer,
                                        action: currentAction
                                    };
                                    
                                    console.log('   Playing animation on character');
                                    
                                    // Update timeline
                                    timelineSlider.max = animationDuration * 1000;
                                    
                                    // Show controls
                                    playbackControls.style.display = 'flex';
                                } else {
                                    console.warn('âš ï¸ No animations found in FBX file');
                                }
                                
                                // Force initial render
                                currentRenderer.render(currentScene, currentCamera);
                                console.log('   âœ… Animation applied - Triangles:', currentRenderer.info.render.triangles);
                            },
                            (xhr) => {
                                const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                                if (percent % 25 === 0 || percent === '100') {
                                    console.log(`ðŸ“¥ Loading animation: ${percent}%`);
                                }
                            },
                            (error) => {
                                console.error('âŒ Failed to load animation:', error);
                            }
                        );
                    },
                    (xhr) => {
                        const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                        if (percent % 25 === 0 || percent === '100') {
                            console.log(`ðŸ“¥ Loading character: ${percent}%`);
                        }
                    },
                    (error) => {
                        console.error('âŒ Failed to load character:', error);
                    }
                );
            }
            
            // Initialize Animation scene
            function initAnimationScene() {
                console.log('ðŸŽ¬ Initializing animation scene');
                currentScene = new THREE.Scene();
                currentScene.background = new THREE.Color(0xffffff); // Match Characters tab
                
                // Camera
                const viewerElement = document.querySelector('.animation-viewer');
                const width = viewerElement.clientWidth - 280; // Subtract sidebar width
                const height = viewerElement.clientHeight;
                const aspect = width / height;
                currentCamera = new THREE.PerspectiveCamera(45, aspect, 0.1, 2000);
                currentCamera.position.set(0, 1.6, 3);
                
                console.log('Canvas size:', width, 'x', height);
                console.log('Canvas element:', animationsCanvas);
                
                // Renderer
                currentRenderer = new THREE.WebGLRenderer({ 
                    canvas: animationsCanvas,
                    antialias: true 
                });
                currentRenderer.setSize(width, height);
                currentRenderer.setPixelRatio(window.devicePixelRatio);
                currentRenderer.shadowMap.enabled = true;
                currentRenderer.shadowMap.type = THREE.PCFSoftShadowMap; // Match Characters tab
                
                // Set canvas style dimensions to match
                animationsCanvas.style.width = '100%';
                animationsCanvas.style.height = '100%';
                
                console.log('Renderer configured:', {
                    size: { width, height },
                    pixelRatio: window.devicePixelRatio,
                    canvasStyle: { 
                        width: animationsCanvas.style.width, 
                        height: animationsCanvas.style.height 
                    }
                });
                
                // Lights - Match Characters tab exactly
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                currentScene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5); // Match Characters tab
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.near = 0.1;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -10;
                directionalLight.shadow.camera.right = 10;
                directionalLight.shadow.camera.top = 10;
                directionalLight.shadow.camera.bottom = -10;
                currentScene.add(directionalLight);
                
                // Add subtle rim light - Match Characters tab
                const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
                rimLight.position.set(-5, 5, -5);
                currentScene.add(rimLight);
                
                // Add checkerboard floor - Match Characters tab
                const floorSize = 20;
                const checkerSize = 1;
                const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
                
                // Create checkerboard texture
                const animCheckerCanvas = document.createElement('canvas');
                animCheckerCanvas.width = 128;
                animCheckerCanvas.height = 128;
                const animCtx = animCheckerCanvas.getContext('2d');
                const animSquareSize = animCheckerCanvas.width / (floorSize / checkerSize);
                
                for (let i = 0; i < floorSize / checkerSize; i++) {
                    for (let j = 0; j < floorSize / checkerSize; j++) {
                        animCtx.fillStyle = (i + j) % 2 === 0 ? '#e0e0e0' : '#999999';
                        animCtx.fillRect(i * animSquareSize, j * animSquareSize, animSquareSize, animSquareSize);
                    }
                }
                
                const animCheckerTexture = new THREE.CanvasTexture(animCheckerCanvas);
                animCheckerTexture.wrapS = THREE.RepeatWrapping;
                animCheckerTexture.wrapT = THREE.RepeatWrapping;
                animCheckerTexture.repeat.set(1, 1);
                
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    map: animCheckerTexture,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                currentScene.add(floor);
                
                // Controls
                currentControls = new THREE.OrbitControls(currentCamera, currentRenderer.domElement);
                currentControls.enableDamping = true;
                currentControls.dampingFactor = 0.05;
                
                console.log('ðŸŽ® Scene initialized:', {
                    canvas: { width, height },
                    scene: currentScene,
                    camera: currentCamera,
                    renderer: currentRenderer
                });
                
                // Add window resize handler
                window.addEventListener('resize', () => {
                    const viewerElement = document.querySelector('.animation-viewer');
                    const newWidth = viewerElement.clientWidth - 280;
                    const newHeight = viewerElement.clientHeight;
                    
                    currentCamera.aspect = newWidth / newHeight;
                    currentCamera.updateProjectionMatrix();
                    currentRenderer.setSize(newWidth, newHeight);
                });
                
                // Start animation loop
                animateAnimationScene();
                console.log('ðŸ”„ Animation loop started');
            }
            
            // Animation loop
            function animateAnimationScene() {
                requestAnimationFrame(animateAnimationScene);
                
                const delta = currentClock.getDelta();
                
                if (currentMixer && isPlaying) {
                    currentMixer.update(delta);
                    
                    // Update timeline with frame count
                    if (currentAction) {
                        const currentTime = currentAction.time;
                        const fps = 30; // Mixamo standard FPS
                        const currentFrame = Math.floor(currentTime * fps);
                        const totalFrames = Math.floor(animationDuration * fps);
                        timelineSlider.value = currentTime * 1000;
                        frameDisplay.textContent = `Frame ${currentFrame}/${totalFrames}`;
                    }
                }
                
                if (currentControls) currentControls.update();
                if (currentRenderer && currentScene && currentCamera) {
                    currentRenderer.render(currentScene, currentCamera);
                }
            }
            
            console.log('âœ… Animation loop function defined');
            
            // Playback controls
            playPauseBtn.addEventListener('click', () => {
                if (!currentAction) return;
                
                isPlaying = !isPlaying;
                playPauseBtn.textContent = isPlaying ? 'â¸' : 'â–¶';
                
                if (!isPlaying) {
                    currentAction.paused = true;
                } else {
                    currentAction.paused = false;
                }
            });
            
            timelineSlider.addEventListener('input', (e) => {
                if (!currentAction) return;
                
                const time = parseFloat(e.target.value) / 1000;
                currentAction.time = time;
                currentMixer.update(0); // Force update
                const currentFrame = Math.floor(time * 30);
                const totalFrames = Math.floor(animationDuration * 30);
                timeDisplay.textContent = `${currentFrame} / ${totalFrames}`;
            });
            
            // Initial render
            console.log('ðŸš€ initAnimationsTab complete, calling renderMotionCards()');
            console.log('Motion grid element:', motionGrid);
            console.log('Number of motions to render:', motions.length);
            renderMotionCards();
        }
        
        // Blend Tab Logic
        function initBlendTab() {
            console.log('ðŸŽ¨ Initializing Blend Tab');
            
            const startBlendBtn = document.getElementById('start-blend-btn');
            const selectedMotionsList = document.getElementById('selected-motions-list');
            const playBlendBtn = document.getElementById('play-blend-btn');
            const blendScrubber = document.getElementById('blend-scrubber');
            const blendTimeDisplay = document.getElementById('blend-time-display');
            
            // Guard against missing elements
            if (!startBlendBtn || !selectedMotionsList) {
                console.warn('âš ï¸ Some blend tab elements not found, using minimal initialization');
                return;
            }
            
            let selectedMotions = [];
            let isBlendPlaying = false;
            
            // Function to select motions from animations tab
            window.selectMotionForBlend = function(motion) {
                if (selectedMotions.length >= 3) {
                    console.log('âš ï¸ Maximum 3 motions can be selected');
                    return;
                }
                
                if (selectedMotions.find(m => m.id === motion.id)) {
                    console.log('âš ï¸ Motion already selected');
                    return;
                }
                
                selectedMotions.push(motion);
                updateSelectedMotionsList();
                console.log('âœ… Added motion to blend:', motion.name);
            };
            
            function updateSelectedMotionsList() {
                if (selectedMotions.length === 0) {
                    selectedMotionsList.innerHTML = '<div style="color: #999; font-size: 12px;">No motions selected</div>';
                    startBlendBtn.disabled = true;
                } else {
                    selectedMotionsList.innerHTML = selectedMotions.map((m, i) => 
                        `<div style="padding: 4px 0; font-size: 12px;">
                            <span style="color: ${['#4CAF50', '#FF9800', '#2196F3'][i]};">â—</span> ${m.name}
                        </div>`
                    ).join('');
                    startBlendBtn.disabled = selectedMotions.length < 2;
                }
            }
            
            startBlendBtn.addEventListener('click', () => {
                console.log('ðŸŽ¬ Starting blend with', selectedMotions.length, 'motions');
                initializeBlendViewers();
            });
            
            function initializeBlendViewers() {
                // Show appropriate number of viewers
                for (let i = 0; i < selectedMotions.length; i++) {
                    const viewer = document.getElementById(`blend-viewer-${i + 1}`);
                    const motionName = document.getElementById(`motion-name-${i + 1}`);
                    viewer.style.display = 'block';
                    motionName.textContent = selectedMotions[i].name;
                    
                    // Initialize 3D scene for this viewer
                    initBlendViewerScene(i + 1, selectedMotions[i]);
                }
                
                // Initialize output viewer
                initBlendOutputScene();
                
                // Setup timeline zones
                setupBlendTimeline();
                
                console.log('âœ… Blend viewers initialized');
            }
            
            function initBlendViewerScene(viewerIndex, motion) {
                const canvas = document.getElementById(`blend-canvas-${viewerIndex}`);
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                
                // Simple setup for now - will expand later
                console.log(`ðŸ“ Initialized viewer ${viewerIndex} for ${motion.name}`);
            }
            
            function initBlendOutputScene() {
                const canvas = document.getElementById('blend-output-canvas');
                console.log('ðŸ“ Initialized output viewer');
            }
            
            function setupBlendTimeline() {
                const timelineCanvas = document.getElementById('blend-timeline-canvas');
                const ctx = timelineCanvas.getContext('2d');
                const zonesContainer = document.getElementById('timeline-zones');
                
                // Clear existing zones
                zonesContainer.innerHTML = '';
                
                // Create color-coded timeline for each motion
                const width = timelineCanvas.parentElement.clientWidth;
                const height = 50;
                timelineCanvas.width = width;
                timelineCanvas.height = height;
                
                const colors = ['#4CAF50', '#FF9800', '#2196F3'];
                const zoneHeight = height / selectedMotions.length;
                
                selectedMotions.forEach((motion, i) => {
                    ctx.fillStyle = colors[i];
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(0, i * zoneHeight, width, zoneHeight);
                });
                
                // Add blend zones (crosshatch areas)
                if (selectedMotions.length >= 2) {
                    // Example: 20-40% is blend zone between motion 1 and 2
                    const blendZone1 = document.createElement('div');
                    blendZone1.className = 'blend-zone';
                    blendZone1.style.left = '20%';
                    blendZone1.style.width = '20%';
                    zonesContainer.appendChild(blendZone1);
                    
                    if (selectedMotions.length === 3) {
                        // 60-80% is blend zone for motion 3
                        const blendZone2 = document.createElement('div');
                        blendZone2.className = 'blend-zone';
                        blendZone2.style.left = '60%';
                        blendZone2.style.width = '20%';
                        zonesContainer.appendChild(blendZone2);
                    }
                }
                
                console.log('ðŸ“Š Timeline setup complete with', selectedMotions.length, 'motion zones');
            }
            
            playBlendBtn.addEventListener('click', () => {
                isBlendPlaying = !isBlendPlaying;
                playBlendBtn.textContent = isBlendPlaying ? 'â¸' : 'â–¶';
            });
            
            blendScrubber.addEventListener('input', (e) => {
                const frame = parseInt(e.target.value);
                blendTimeDisplay.textContent = `${frame} / 100`;
            });
            
            // Initialize with empty state
            updateSelectedMotionsList();
            
            console.log('âœ… Blend tab initialized');
        }
        
        // Auto-load demo artifacts for faster testing
        async function autoLoadArtifactsDemo() {
            console.log('ðŸš€ Auto-loading artifacts demo...');
            
            try {
                // Define test motions with actual frame data
                const testMotions = [
                    {
                        name: 'Salsa Dancing Twirl And Clap',
                        path: '/static/models/data/mixamo_anims/fbx/michele/michelle.fbx/Salsa Dancing Twirl And Clap.fbx',
                        slot: 1,
                        weight: 0.43,
                        frames: 67
                    },
                    {
                        name: 'Swing Dance Charleston _Crazy Legs_',
                        path: '/static/models/data/mixamo_anims/fbx/michele/michelle.fbx/Swing Dance Charleston _Crazy Legs_.fbx',
                        slot: 2,
                        weight: 0.43,
                        frames: 74
                    },
                    {
                        name: 'Wave Hip Hop Dance Variation One',
                        path: '/static/models/data/mixamo_anims/fbx/michele/michelle.fbx/Wave Hip Hop Dance Variation One.fbx',
                        slot: 3,
                        weight: 0.14,
                        frames: 505
                    }
                ];
                
                console.log('  ðŸ“¤ Calling artifacts API directly...');
                
                // Call artifacts API directly with test data
                const response = await fetch('/api/artifacts/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        motion_paths: testMotions.map(m => m.path),
                        weights: testMotions.map(m => m.weight),
                        crosshatch_offsets: [0, 0, 0],
                        actual_frame_counts: testMotions.map(m => m.frames),
                        blend_mode: 'smoothstep',
                        transition_frames: 30
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }
                
                const result = await response.json();
                console.log('  âœ… Artifacts generated:', result);
                
                // Store in blend state
                blendState.currentArtifacts = result;
                
                // Update blend state with motion info
                testMotions.forEach((motion, idx) => {
                    blendState.slots[motion.slot] = {
                        motion: {
                            name: motion.name,
                            path: motion.path
                        }
                    };
                    blendState.frameCounts[motion.slot] = motion.frames;
                    
                    // Set weight slider
                    const weightSlider = document.getElementById(`weight-slider-${motion.slot}`);
                    if (weightSlider) {
                        weightSlider.value = motion.weight * 100;
                        const weightValue = document.getElementById(`weight-value-${motion.slot}`);
                        if (weightValue) {
                            weightValue.textContent = `${(motion.weight * 100).toFixed(0)}%`;
                        }
                    }
                });
                
                // Create mock blend preview for thumbnails
                console.log('  Creating blend preview with proper color coding...');
                const blendContainer = document.getElementById('frame-previews-blend');
                const blendOverlapViz = document.getElementById('blend-overlap-viz');
                
                if (blendContainer && result.motion_segments) {
                    blendContainer.innerHTML = '';
                    if (blendOverlapViz) blendOverlapViz.innerHTML = '';
                    
                    let currentFrameIdx = 0;
                    const blendFrames = result.transition_frames_each || 30;
                    
                    // Process each motion segment
                    for (let segIdx = 0; segIdx < result.motion_segments.length; segIdx++) {
                        const segment = result.motion_segments[segIdx];
                        const segmentFrames = segment.frame_count;
                        
                        // Add 3 motion thumbnails (start, middle, end)
                        const indices = [
                            currentFrameIdx,
                            currentFrameIdx + Math.floor(segmentFrames / 2),
                            currentFrameIdx + segmentFrames - 1
                        ];
                        
                        for (const idx of indices) {
                            const canvas = document.createElement('canvas');
                            canvas.width = 64;
                            canvas.height = 64;
                            canvas.className = 'frame-thumb';
                            
                            const ctx = canvas.getContext('2d');
                            // Motion color: blue/purple gradient
                            const gradient = ctx.createLinearGradient(0, 0, 64, 64);
                            gradient.addColorStop(0, '#667eea');
                            gradient.addColorStop(1, '#764ba2');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(0, 0, 64, 64);
                            
                            // Frame number
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 10px Arial';
                            ctx.fillText(`F${idx + 1}`, 5, 15);
                            
                            blendContainer.appendChild(canvas);
                        }
                        
                        currentFrameIdx += segmentFrames;
                        
                        // Add blend sequence thumbnails if not last segment
                        if (segIdx < result.motion_segments.length - 1) {
                            const blendIndices = [
                                currentFrameIdx + Math.floor(blendFrames * 0.25),
                                currentFrameIdx + Math.floor(blendFrames * 0.5),
                                currentFrameIdx + Math.floor(blendFrames * 0.75)
                            ];
                            
                            for (const idx of blendIndices) {
                                const canvas = document.createElement('canvas');
                                canvas.width = 64;
                                canvas.height = 64;
                                canvas.className = 'frame-thumb';
                                
                                const ctx = canvas.getContext('2d');
                                // Blend color: orange gradient
                                const gradient = ctx.createLinearGradient(0, 0, 64, 64);
                                gradient.addColorStop(0, '#FF6700');
                                gradient.addColorStop(1, '#FF9800');
                                ctx.fillStyle = gradient;
                                ctx.fillRect(0, 0, 64, 64);
                                
                                // Frame number
                                ctx.fillStyle = 'white';
                                ctx.font = 'bold 10px Arial';
                                ctx.fillText(`F${idx + 1}`, 5, 15);
                                
                                blendContainer.appendChild(canvas);
                            }
                            
                            currentFrameIdx += blendFrames;
                        }
                    }
                    
                    // Create crosshatch overlays for blend sequences
                    if (blendOverlapViz) {
                        const thumbnailWidth = 64;
                        const thumbnailGap = -15;
                        const effectiveWidth = thumbnailWidth + thumbnailGap;
                        
                        let position = 0;
                        const colors = ['green', 'blue', 'orange'];
                        
                        // Add crosshatch for each blend transition
                        for (let i = 0; i < result.motion_segments.length; i++) {
                            // Skip motion segment (3 thumbnails)
                            position += effectiveWidth * 3;
                            
                            // Add crosshatch for blend sequence (3 thumbnails)
                            if (i < result.motion_segments.length - 1) {
                                const overlay = document.createElement('div');
                                overlay.className = `overlap-segment ${colors[i % colors.length]}`;
                                overlay.style.position = 'absolute';
                                overlay.style.left = `${position}px`;
                                overlay.style.width = `${effectiveWidth * 3}px`;
                                overlay.style.height = '35px';
                                overlay.style.bottom = '25px';
                                overlay.style.background = i === 0 ? 
                                    'repeating-linear-gradient(45deg, rgba(76, 175, 80, 0.3), rgba(76, 175, 80, 0.3) 10px, transparent 10px, transparent 20px)' :
                                    i === 1 ?
                                    'repeating-linear-gradient(45deg, rgba(33, 150, 243, 0.3), rgba(33, 150, 243, 0.3) 10px, transparent 10px, transparent 20px)' :
                                    'repeating-linear-gradient(45deg, rgba(255, 152, 0, 0.3), rgba(255, 152, 0, 0.3) 10px, transparent 10px, transparent 20px)';
                                overlay.style.border = i === 0 ? '2px solid #4CAF50' : i === 1 ? '2px solid #2196F3' : '2px solid #FF9800';
                                overlay.style.borderRadius = '8px';
                                overlay.style.pointerEvents = 'none';
                                overlay.style.zIndex = '10';
                                blendOverlapViz.appendChild(overlay);
                                
                                position += effectiveWidth * 3;
                            }
                        }
                    }
                    
                    console.log('  âœ… Created blend preview with', blendContainer.children.length, 'thumbnails and crosshatch overlays');
                }
                
                // Load artifacts in viewer (with 3 second delay for thumbnail)
                console.log('  Loading artifacts in viewer...');
                await loadArtifactsInViewer(result);
                
                // Switch to Artifacts tab after everything is loaded
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                console.log('  Switching to Artifacts tab...');
                const artifactsTabBtn = document.querySelector('[data-tab="artifacts"]');
                if (artifactsTabBtn) {
                    artifactsTabBtn.click();
                }
                
                console.log('âœ… Auto-load complete! Artifacts ready with:', result.artifacts.length, 'frames');
                
            } catch (error) {
                console.error('âŒ Auto-load failed:', error);
            }
        }
        
        // Initialize blend tab on load
        document.addEventListener('DOMContentLoaded', () => {
            initBlendTab();
            // Initialize artifacts viewer synchronously
            try {
                initArtifactsViewer();
                console.log('âœ… All tabs initialized successfully');
                
                // Auto-load artifacts for testing (3 seconds after page load)
                setTimeout(() => {
                    autoLoadArtifactsDemo();
                }, 3000);
            } catch (error) {
                console.error('âŒ Failed to initialize artifacts viewer:', error);
            }
        });
        
        // ===========================
        // Artifacts Tab 3D Viewer
        // ===========================
        
        let artifactsViewer = null;
        
        function initArtifactsViewer() {
            console.log('ðŸŽ¬ Initializing artifacts viewer...');
            artifactsViewer = new ArtifactsViewer();
            const success = artifactsViewer.init();
            
            if (!success) {
                console.error('âŒ Failed to initialize artifacts viewer');
                return;
            }
            
            // Listen for tab changes to load artifacts
            document.querySelector('[data-tab="artifacts"]').addEventListener('click', () => {
                if (window.blendState && window.blendState.currentArtifacts) {
                    console.log('ðŸ”„ Switching to artifacts tab, loading artifacts...');
                    artifactsViewer.loadArtifacts(window.blendState.currentArtifacts);
                }
            });
            
            console.log('âœ… Artifacts viewer ready');
        }
        
        class ArtifactsViewer {
            constructor() {
                this.canvas = document.getElementById('artifacts-canvas');
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.character = null;
                this.mixer = null;
                this.controls = null;
                this.clock = new THREE.Clock();
                
                this.currentArtifacts = null;
                this.currentFrameIndex = 0;
                this.isPlaying = false;
                this.playbackSpeed = 1.0;
                this.animationFrameId = null;
                
                this.motionSegments = [];
                this.transitionFrames = [];
                this.sequenceData = []; // Full sequence with segments and transitions
            }
            
            init() {
                if (!this.canvas) {
                    console.error('âŒ Artifacts canvas not found - viewer cannot initialize');
                    return false;
                }
                
                // Get parent container size
                const container = this.canvas.parentElement;
                const width = container.clientWidth || 800;
                const height = container.clientHeight || 600;
                
                console.log(`ðŸŽ¬ Initializing artifacts viewer: ${width}x${height}`);
                
                // Setup Three.js scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf5f5f5); // Match page theme
                
                // Camera (match Character tab setup)
                const aspect = width / height;
                this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
                this.camera.position.set(0, 1.6, 3);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true
                });
                this.renderer.setSize(width, height);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Orbit controls
                this.controls = new THREE.OrbitControls(this.camera, this.canvas);
                this.controls.target.set(0, 1, 0);
                this.controls.update();
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7.5);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.near = 0.1;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -5;
                directionalLight.shadow.camera.right = 5;
                directionalLight.shadow.camera.top = 5;
                directionalLight.shadow.camera.bottom = -5;
                this.scene.add(directionalLight);
                
                // Checkerboard ground (match Character tab)
                const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0xcccccc);
                this.scene.add(gridHelper);
                
                // Load character model
                this.loadCharacter();
                
                // Setup playback controls
                this.setupPlaybackControls();
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Start render loop
                this.animate();
                
                console.log('âœ… Artifacts viewer initialized successfully');
                return true;
            }
            
            onWindowResize() {
                if (!this.canvas || !this.renderer || !this.camera) return;
                
                const container = this.canvas.parentElement;
                const width = container.clientWidth || 800;
                const height = container.clientHeight || 600;
                
                // Prevent negative or zero dimensions that cause WebGL errors
                if (width <= 0 || height <= 0) {
                    console.warn('âš ï¸ Invalid viewport dimensions, skipping resize:', width, height);
                    return;
                }
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
            
            loadCharacter() {
                console.log('ðŸŽ­ Step 4: Loading character model...');
                const loader = new THREE.FBXLoader();
                const characterPath = '/static/models/Ch03_nonPBR.fbx';
                
                console.log('  Character path:', characterPath);
                
                loader.load(
                    characterPath,
                    (fbx) => {
                        this.character = fbx;
                        this.character.scale.set(0.01, 0.01, 0.01);
                        this.character.position.set(0, 0, 0);
                        
                        this.character.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                // Ensure proper material (match Character tab)
                                if (child.material) {
                                    child.material.side = THREE.FrontSide;
                                    child.material.needsUpdate = true;
                                }
                            }
                        });
                        
                        this.scene.add(this.character);
                        this.mixer = new THREE.AnimationMixer(this.character);
                        
                        // Center camera on character
                        this.centerCameraOnCharacter();
                        
                        console.log('âœ… Character loaded successfully in artifacts viewer');
                        console.log('  Character object:', this.character);
                        console.log('  Scene children count:', this.scene.children.length);
                    },
                    (progress) => {
                        const percent = (progress.loaded / progress.total * 100).toFixed(0);
                        console.log(`  Loading character: ${percent}%`);
                    },
                    (error) => {
                        console.error('âŒ Failed to load character:', error);
                        console.error('  Error details:', error.message || error);
                    }
                );
            }
            
            centerCameraOnCharacter() {
                if (!this.character) return;
                
                const box = new THREE.Box3().setFromObject(this.character);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                // Update controls target
                this.controls.target.copy(center);
                
                // Position camera to see full character (match Character tab)
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = this.camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                cameraZ *= 1.5; // Add some padding
                
                this.camera.position.set(center.x + cameraZ * 0.5, center.y + size.y * 0.3, center.z + cameraZ);
                this.camera.lookAt(center);
                this.controls.update();
            }
            
            async loadArtifacts(artifactData) {
                console.log('ðŸ“¦ Step 5: Loading artifacts into 3D viewer');
                console.log('  Artifact data:', artifactData);
                console.log('  Character loaded:', !!this.character);
                console.log('  Scene initialized:', !!this.scene);
                
                if (!this.scene) {
                    console.error('âŒ Scene not initialized');
                    return;
                }

                // ===== COPY ALL SETTINGS FROM CHARACTERS TAB FOR CONTINUITY =====
                // Look for the main character viewer (from Characters tab)
                const mainCharacterCanvas = document.getElementById('character-viewer-canvas');
                if (mainCharacterCanvas && window.mainCharacterViewer) {
                    console.log('ðŸŽ¯ Copying camera and scene settings from Characters tab...');
                    
                    const mainViewer = window.mainCharacterViewer;
                    
                    // Copy camera position and orientation
                    if (mainViewer.camera) {
                        this.camera.position.copy(mainViewer.camera.position);
                        this.camera.quaternion.copy(mainViewer.camera.quaternion);
                        this.camera.up.copy(mainViewer.camera.up);
                        this.camera.zoom = mainViewer.camera.zoom;
                        this.camera.updateProjectionMatrix();
                    }
                    
                    // Copy controls target if available
                    if (mainViewer.controls && this.controls) {
                        this.controls.target.copy(mainViewer.controls.target);
                        this.controls.update();
                    }
                    
                    // Match ground plane visibility and style
                    const mainGround = mainViewer.scene.getObjectByName('ground');
                    const artifactsGround = this.scene.getObjectByName('ground');
                    if (mainGround && artifactsGround) {
                        artifactsGround.visible = mainGround.visible;
                        artifactsGround.position.copy(mainGround.position);
                        artifactsGround.rotation.copy(mainGround.rotation);
                        artifactsGround.scale.copy(mainGround.scale);
                    }
                    
                    // Match lighting
                    const mainLights = mainViewer.scene.children.filter(c => c.isLight);
                    const artifactsLights = this.scene.children.filter(c => c.isLight);
                    mainLights.forEach((mainLight, idx) => {
                        if (artifactsLights[idx]) {
                            artifactsLights[idx].intensity = mainLight.intensity;
                            artifactsLights[idx].position.copy(mainLight.position);
                        }
                    });
                    
                    console.log('âœ… Settings copied from Characters tab');
                }
                
                /**
                 * NOTE: Artifacts are generated server-side using BlendAnim with optional Gemini encoding.
                 * 
                 * When Gemini is available:
                 * - FBX files are processed through Gemini Motion Embedder
                 * - Creates rich semantic embeddings for motion understanding
                 * - Enables advanced motion analysis and similarity computation
                 * 
                 * Fallback mode (ufbx parser):
                 * - Direct FBX binary parsing using ufbx library
                 * - Extracts skeletal positions without semantic encoding
                 * - Faster but less semantically aware
                 * 
                 * The client (this viewer) receives pre-generated transition frames
                 * with positions already computed by BlendAnim smoothstep temporal conditioning.
                 * 
                 * BlendAnim metrics (from repository analysis):
                 * - Coverage: Motion space utilization across frames
                 * - Global Diversity: NN dynamic programming across full sequence
                 * - Local Diversity: Per-window cost minimization
                 * - L2 Velocity: Frame-to-frame velocity changes (smoothness)
                 * - L2 Acceleration: Second-order smoothness (jerk reduction)
                 * - Foot Contact: Ground contact preservation
                 * - Root Velocity: XZ plane linear velocity matching
                 */
                
                this.currentArtifacts = artifactData;
                this.motionSegments = artifactData.motion_segments || [];
                
                // Parse artifact frames
                const frames = artifactData.frames || artifactData.artifacts || [];
                if (!frames || frames.length === 0) {
                    console.error('âŒ No frames in artifact data');
                    return;
                }

                this.sequenceData = frames;
                console.log(`  Loaded ${frames.length} frames from artifacts`);
                
                // ===== MOTION SEGMENT BREAKDOWN =====
                if (this.motionSegments.length > 0) {
                    console.log('ðŸ“Š Motion segment breakdown:');
                    this.motionSegments.forEach((seg, idx) => {
                        console.log(`    Segment ${idx + 1}: ${seg.num_frames} frames (${seg.type || 'motion'})`);
                    });
                }

                // Log first frame structure for debugging
                if (frames.length > 0) {
                    console.log('  First frame sample:', frames[0]);
                }

                console.log(`ðŸ¤– Encoding method: ${artifactData.encoding_method || 'ufbx parser (Gemini unavailable)'}`);
                
                // Show metrics panel (if exists)
                const metricsPanel = document.getElementById('metrics-panel');
                if (metricsPanel && artifactData.aggregate_metrics) {
                    this.displayMetrics(artifactData.aggregate_metrics);
                    metricsPanel.style.display = 'block';
                }
                
                // Show playback controls
                const playbackControls = document.getElementById('artifact-playback-controls');
                if (playbackControls) {
                    playbackControls.style.display = 'flex';
                    console.log('  âœ… Playback controls shown');
                }
                
                // ===== SEQUENTIAL MOTION LOADING APPROACH =====
                this.currentFrameIndex = 0;
                if (this.character && frames.length > 0) {
                    console.log('  Creating animation using SEQUENTIAL segment approach...');
                    
                    try {
                        // Clear any existing animation
                        if (this.mixer) {
                            this.mixer.stopAllAction();
                        }
                        
                        // Create animation using SEQUENTIAL segment approach
                        await this.createSequentialAnimation(frames, this.motionSegments, artifactData);
                        
                    } catch (error) {
                        console.error('âŒ Failed to create sequential animation:', error);
                        // Fallback to old method if sequential fails
                        this.createAnimationFromArtifacts();
                    }
                } else {
                    console.warn('  âš ï¸ No sequence data or character not loaded');
                }
                
                // Update timeline
                const timeline = document.getElementById('artifact-timeline-slider');
                if (timeline) {
                    timeline.max = Math.max(0, this.sequenceData.length - 1);
                    timeline.value = 0;
                    console.log(`  âœ… Timeline set: 0 to ${timeline.max}`);
                }
                
                // Setup crosshatch dragging for artifacts tab after elements are copied
                setTimeout(() => {
                    const artifactsOverlapViz = document.getElementById('artifacts-overlap-viz');
                    if (artifactsOverlapViz) {
                        const artifactsFramePreviews = document.getElementById('artifacts-frame-previews');
                        
                        // Re-attach dragging to newly copied crosshatch elements
                        const crosshatchElements = artifactsOverlapViz.querySelectorAll('.overlap-segment');
                        crosshatchElements.forEach((crosshatch, index) => {
                            crosshatch.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                crosshatch.classList.add('dragging');
                                
                                activeDrag = {
                                    slot: index, // Use index for artifacts crosshatch
                                    crosshatch: crosshatch,
                                    frameContainer: artifactsFramePreviews,
                                    startX: e.clientX,
                                    startLeft: parseFloat(crosshatch.style.left || '0'),
                                    isArtifacts: true
                                };
                                
                                console.log(`ðŸŽ¯ Started dragging artifacts crosshatch segment ${index}`);
                            });
                        });
                        
                        console.log(`  âœ… Set up dragging for ${crosshatchElements.length} artifacts crosshatch segments`);
                    }
                }, 100); // Small delay to ensure DOM is updated
                
                console.log('âœ… Artifacts loaded successfully in 3D viewer');
            }
            
            async createSequentialAnimation(frames, motionSegments, artifactData) {
                console.log('ðŸŽ¬ Creating SEQUENTIAL animation from segments');
                console.log(`  Total frames: ${frames.length}`);
                console.log(`  Segments: ${motionSegments.length}`);
                
                // Get skeleton
                const skeleton = this.character.skeleton;
                if (!skeleton) {
                    throw new Error('Character has no skeleton');
                }
                
                const bones = skeleton.bones;
                console.log(`  Found skeleton with ${bones.length} bones`);
                
                // Verify first frame has position data
                if (!frames[0].positions || frames[0].positions.length === 0) {
                    throw new Error('First frame has no positions data');
                }
                
                console.log(`  First frame has ${frames[0].positions.length} joint positions`);
                
                // Create tracks for each bone - load data SEQUENTIALLY by segment
                const tracks = [];
                const fps = 30; // Standard FPS
                const frameDuration = 1.0 / fps;
                
                // Build segment metadata for sequential loading
                let frameOffset = 0;
                const segmentInfo = [];
                
                for (let segIdx = 0; segIdx < motionSegments.length; segIdx++) {
                    const seg = motionSegments[segIdx];
                    segmentInfo.push({
                        name: `Segment ${segIdx + 1}`,
                        type: seg.type || (segIdx === motionSegments.length - 1 ? 'smoothstep' : 'motion'),
                        startFrame: frameOffset,
                        endFrame: frameOffset + seg.num_frames - 1,
                        numFrames: seg.num_frames,
                        weight: seg.weight,
                        offset: seg.offset
                    });
                    frameOffset += seg.num_frames;
                }
                
                console.log('ðŸ“Š Segment timeline:');
                segmentInfo.forEach(info => {
                    console.log(`  ${info.name} (${info.type}): frames ${info.startFrame}-${info.endFrame} (${info.numFrames} frames)`);
                });
                
                // Create position tracks for each bone (no rotation data in artifacts)
                for (let boneIdx = 0; boneIdx < Math.min(bones.length, frames[0].positions.length); boneIdx++) {
                    const bone = bones[boneIdx];
                    const boneName = bone.name;
                    
                    // Time values for each frame
                    const times = [];
                    const positions = [];
                    
                    // Process each segment sequentially
                    for (const segInfo of segmentInfo) {
                        const segFrames = frames.slice(segInfo.startFrame, segInfo.endFrame + 1);
                        
                        for (let frameIdx = 0; frameIdx < segFrames.length; frameIdx++) {
                            const frame = segFrames[frameIdx];
                            const globalFrameIdx = segInfo.startFrame + frameIdx;
                            const time = globalFrameIdx * frameDuration;
                            
                            times.push(time);
                            
                            // Get position for this bone in this frame
                            // FIX: positions is array of [x,y,z] arrays, not objects
                            if (frame.positions && frame.positions[boneIdx]) {
                                const pos = frame.positions[boneIdx];
                                // pos is [x, y, z] array, not {x, y, z} object
                                positions.push(pos[0], pos[1], pos[2]);
                            } else {
                                // Use T-pose if missing
                                positions.push(
                                    bone.position.x,
                                    bone.position.y,
                                    bone.position.z
                                );
                            }
                        }
                    }
                    
                    // Create position track only (no rotation data available)
                    const posTrack = new THREE.VectorKeyframeTrack(
                        `${boneName}.position`,
                        times,
                        positions
                    );
                    
                    tracks.push(posTrack);
                }
                
                console.log(`  Created ${tracks.length} position tracks (${tracks.length} bones)`);
                
                // Create animation clip
                const duration = (frames.length - 1) * frameDuration;
                const clip = new THREE.AnimationClip('ArtifactSequence', duration, tracks);
                
                // Setup mixer and action
                if (!this.mixer) {
                    this.mixer = new THREE.AnimationMixer(this.character);
                }
                
                this.mixer.stopAllAction();
                const action = this.mixer.clipAction(clip);
                
                // Start PAUSED - user must click play or thumbnail
                action.paused = true;
                action.time = 0;
                action.play();
                this.isPlaying = false;
                
                console.log('âœ… Sequential animation created (paused, click play to start)');
                console.log(`  Duration: ${duration.toFixed(2)}s (${frames.length} frames at ${fps} fps)`);
                console.log(`  Segments loaded: ${segmentInfo.length}`);
            }
            
            createAnimationFromArtifacts() {
                if (!this.character || !this.sequenceData || this.sequenceData.length === 0) {
                    console.error('Cannot create animation: missing character or sequence data');
                    return;
                }
                
                console.log(`ðŸŽ¬ Creating animation from ${this.sequenceData.length} artifact frames`);
                
                // Find the skeleton
                let skinnedMesh = null;
                this.character.traverse((child) => {
                    if (child.isSkinnedMesh && child.skeleton) {
                        skinnedMesh = child;
                    }
                });
                
                if (!skinnedMesh || !skinnedMesh.skeleton) {
                    console.error('No skeleton found in character');
                    return;
                }
                
                const skeleton = skinnedMesh.skeleton;
                const bones = skeleton.bones;
                
                console.log(`  Found skeleton with ${bones.length} bones`);
                
                // Check if first frame has positions data
                if (!this.sequenceData[0] || !this.sequenceData[0].positions) {
                    console.error('âŒ First frame has no positions data');
                    console.error('  Frame structure:', this.sequenceData[0]);
                    return;
                }
                
                console.log(`  First frame has ${this.sequenceData[0].positions.length} joint positions`);
                
                // Create animation tracks for each bone
                const tracks = [];
                const fps = 30;
                const frameDuration = 1 / fps;
                
                // For each bone, create a position track
                for (let boneIdx = 0; boneIdx < Math.min(bones.length, this.sequenceData[0].positions.length); boneIdx++) {
                    const bone = bones[boneIdx];
                    const times = [];
                    const positions = [];
                    
                    // Collect positions for this bone across all frames
                    for (let frameIdx = 0; frameIdx < this.sequenceData.length; frameIdx++) {
                        const frame = this.sequenceData[frameIdx];
                        if (frame.positions && frame.positions[boneIdx]) {
                            times.push(frameIdx * frameDuration);
                            const pos = frame.positions[boneIdx];
                            // FIX: pos is [x, y, z] array, not {x, y, z} object
                            positions.push(pos[0], pos[1], pos[2]);
                        }
                    }
                    
                    if (times.length > 0) {
                        const track = new THREE.VectorKeyframeTrack(
                            bone.name + '.position',
                            times,
                            positions
                        );
                        tracks.push(track);
                    }
                }
                
                console.log(`  Created ${tracks.length} animation tracks`);
                
                // Create animation clip
                const duration = (this.sequenceData.length - 1) * frameDuration;
                const clip = new THREE.AnimationClip('ArtifactsAnimation', duration, tracks);
                
                // Stop any existing animation
                if (this.currentAction) {
                    this.currentAction.stop();
                }
                
                // Create animation (paused by default, user must click play)
                this.mixer = new THREE.AnimationMixer(this.character);
                this.currentAction = this.mixer.clipAction(clip);
                this.currentAction.setLoop(THREE.LoopRepeat, Infinity);
                // Don't auto-play - wait for user interaction
                
                // Start paused (similar to animations tab)
                this.isPlaying = false;
                const playPauseBtn = document.getElementById('artifact-play-pause-btn');
                if (playPauseBtn) {
                    playPauseBtn.textContent = 'â–¶';
                }
                
                console.log('âœ… Animation created (paused, click play or thumbnail to start)');
                console.log(`  Duration: ${duration.toFixed(2)}s (${this.sequenceData.length} frames at ${fps} fps)`);
            }
            
            displayMetrics(metrics) {
                // Update metric displays with null checks
                const metricCoverage = document.getElementById('metric-coverage');
                const metricLocalDiv = document.getElementById('metric-local-div');
                const metricGlobalDiv = document.getElementById('metric-global-div');
                const metricVelocity = document.getElementById('metric-velocity');
                const metricAccel = document.getElementById('metric-accel');
                const qualityBadge = document.getElementById('quality-badge');
                
                if (metricCoverage) metricCoverage.textContent = (metrics.coverage * 100).toFixed(1) + '%';
                if (metricLocalDiv) metricLocalDiv.textContent = metrics.local_diversity.toFixed(3);
                if (metricGlobalDiv) metricGlobalDiv.textContent = metrics.global_diversity.toFixed(3);
                if (metricVelocity) metricVelocity.textContent = metrics.l2_velocity.toFixed(4);
                if (metricAccel) metricAccel.textContent = metrics.l2_acceleration.toFixed(4);
                
                if (qualityBadge) {
                    qualityBadge.textContent = metrics.quality_tier.toUpperCase();
                    qualityBadge.className = 'quality-badge ' + metrics.quality_tier;
                }
            }
            
            updateFrame(frameIndex) {
                if (!this.sequenceData || frameIndex >= this.sequenceData.length) {
                    console.warn(`âš ï¸ Cannot update frame ${frameIndex}: sequenceData length = ${this.sequenceData?.length || 0}`);
                    return;
                }
                if (!this.character) {
                    console.warn('âš ï¸ Cannot update frame: character not loaded yet');
                    return;
                }
                
                const frameData = this.sequenceData[frameIndex];
                if (!frameData || !frameData.positions) {
                    console.warn(`âš ï¸ Frame ${frameIndex} has no position data`);
                    return;
                }
                
                this.applyPoseToCharacter(frameData.positions);
                
                // Update frame display
                const frameDisplay = document.getElementById('artifact-frame-display');
                if (frameDisplay) {
                    const omega = frameData.omega !== undefined ? frameData.omega.toFixed(3) : 'N/A';
                    const segmentType = frameData.segment_type || frameData.blend_mode || 'unknown';
                    frameDisplay.textContent = `Frame ${frameIndex + 1}/${this.sequenceData.length} (Ï‰=${omega}, ${segmentType})`;
                }
                
                this.currentFrameIndex = frameIndex;
            }
            
            applyPoseToCharacter(positions) {
                if (!this.character || !positions) return;
                
                // positions is [J, 3] array where J is number of joints
                // Apply positions to character skeleton
                const skeleton = this.character.children.find(child => child.skeleton);
                if (!skeleton || !skeleton.skeleton) return;
                
                const bones = skeleton.skeleton.bones;
                
                // Apply position data to each bone
                for (let i = 0; i < Math.min(positions.length, bones.length); i++) {
                    const bone = bones[i];
                    const pos = positions[i];
                    
                    if (bone && pos && pos.length === 3) {
                        // FIX: pos is [x, y, z] array, not {x, y, z} object
                        bone.position.set(pos[0], pos[1], pos[2]);
                    }
                }
                
                // Update skeleton
                if (skeleton.skeleton) {
                    skeleton.skeleton.update();
                }
            }
            
            setupPlaybackControls() {
                const playPauseBtn = document.getElementById('artifact-play-pause-btn');
                const timeline = document.getElementById('artifact-timeline-slider');
                const thumbnail = document.getElementById('artifacts-thumbnail');
                
                // Play/pause button
                playPauseBtn.addEventListener('click', () => {
                    this.togglePlayback();
                });
                
                // Timeline scrubbing
                timeline.addEventListener('input', (e) => {
                    const frameIndex = parseInt(e.target.value);
                    this.updateFrame(frameIndex);
                });
                
                // Thumbnail click to play (similar to animations tab)
                if (thumbnail) {
                    thumbnail.addEventListener('click', () => {
                        console.log('ðŸŽ¬ Thumbnail clicked - starting playback');
                        if (!this.isPlaying && this.currentAction) {
                            this.togglePlayback();
                        }
                    });
                }
            }
            
            togglePlayback() {
                if (!this.currentAction) {
                    console.warn('No animation loaded');
                    return;
                }
                
                this.isPlaying = !this.isPlaying;
                const playPauseBtn = document.getElementById('artifact-play-pause-btn');
                
                if (this.isPlaying) {
                    this.currentAction.play();
                    if (playPauseBtn) playPauseBtn.textContent = 'â¸';
                    console.log('â–¶ Playback started');
                } else {
                    this.currentAction.paused = true;
                    if (playPauseBtn) playPauseBtn.textContent = 'â–¶';
                    console.log('â¸ Playback paused');
                }
            }
            
            animate() {
                this.animationFrameId = requestAnimationFrame(() => this.animate());
                
                const delta = this.clock.getDelta();
                
                // Update animation mixer (plays the blended animation sequence)
                if (this.mixer && this.isPlaying) {
                    this.mixer.update(delta * this.playbackSpeed);
                    
                    // Update timeline slider based on mixer time
                    if (this.currentAction && this.sequenceData) {
                        const fps = 30;
                        const frameDuration = 1 / fps;
                        const currentFrame = Math.floor(this.currentAction.time / frameDuration);
                        
                        const timeline = document.getElementById('artifact-timeline-slider');
                        if (timeline) {
                            timeline.value = currentFrame;
                        }
                        
                        // Update frame display
                        if (currentFrame >= 0 && currentFrame < this.sequenceData.length) {
                            const frameData = this.sequenceData[currentFrame];
                            const frameDisplay = document.getElementById('artifact-frame-display');
                            if (frameDisplay && frameData) {
                                const omega = frameData.omega !== undefined ? frameData.omega.toFixed(3) : 'N/A';
                                const segmentType = frameData.segment_type || frameData.blend_mode || 'unknown';
                                frameDisplay.textContent = `Frame ${currentFrame + 1}/${this.sequenceData.length} (Ï‰=${omega}, ${segmentType})`;
                            }
                        }
                    }
                }
                
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
            
            dispose() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                
                if (this.renderer) {
                    this.renderer.dispose();
                }
            }
        }
    </script>
</body>
</html>
